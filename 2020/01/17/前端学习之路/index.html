<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/icon.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/icon.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/icon.jpg">
  <link rel="mask-icon" href="/images/icon.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.pisho.me","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="JS的东西挺多的，再加上JS的单线程会导致很多地方与其他的编程语言有一些实现上的不同，不过很多东西思想上还是差不多的，感觉 ES6 的文档看着就和看 JavaScript 的文档一样，填补了很多知识细节。2020 应届生找前端，邮件微信 QQ 联系我谢谢。这篇不更新了，太大了写起来都卡😒。分成小篇更新。">
<meta property="og:type" content="article">
<meta property="og:title" content="前端学习之路">
<meta property="og:url" content="http://www.pisho.me/2020/01/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/index.html">
<meta property="og:site_name" content="Pisho&#39;Blogs">
<meta property="og:description" content="JS的东西挺多的，再加上JS的单线程会导致很多地方与其他的编程语言有一些实现上的不同，不过很多东西思想上还是差不多的，感觉 ES6 的文档看着就和看 JavaScript 的文档一样，填补了很多知识细节。2020 应届生找前端，邮件微信 QQ 联系我谢谢。这篇不更新了，太大了写起来都卡😒。分成小篇更新。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.w3school.com.cn/i/dom_navigate.gif">
<meta property="og:image" content="https://media.prod.mdn.mozit.cloud/attachments/2019/03/19/16558/29c6fe062e42a327fb549a081bc56632/box-model.png">
<meta property="og:image" content="https://developer.mozilla.org/files/3739/flex_terms.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2014/07/7B0CC41A-86DC-4E1B-8A69-A410E6764B91.jpg">
<meta property="og:image" content="http://www.pisho.me/images/16bc675a7df7428e.png">
<meta property="og:image" content="http://www.pisho.me/images/16bc6bd331a2116a.png">
<meta property="og:image" content="http://www.pisho.me/images/161bb3c9b220f8cb.">
<meta property="og:image" content="https://image-static.segmentfault.com/162/469/1624694337-5a8fcee951762_articlex">
<meta property="og:image" content="https://image-static.segmentfault.com/275/841/2758414791-5c99c0ef4e3c8_articlex">
<meta property="og:image" content="http://www.pisho.me/images/image-20200401163121542.">
<meta property="article:published_time" content="2020-01-17T09:38:36.000Z">
<meta property="article:modified_time" content="2020-12-23T13:01:18.019Z">
<meta property="article:author" content="Pisho">
<meta property="article:tag" content="学习前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.w3school.com.cn/i/dom_navigate.gif">

<link rel="canonical" href="http://www.pisho.me/2020/01/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>前端学习之路 | Pisho'Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pisho'Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Daily Notes</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.pisho.me/2020/01/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/icon.jpg">
      <meta itemprop="name" content="Pisho">
      <meta itemprop="description" content="本站看运气访问进来,主要是本人的一些学习笔记,一般没有什么干货。不过还是希望能够帮助你学习到什么。由于域名到期，所以换成了 MOE 二次元域名。😄">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pisho'Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          前端学习之路
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-17 17:38:36" itemprop="dateCreated datePublished" datetime="2020-01-17T17:38:36+08:00">2020-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 21:01:18" itemprop="dateModified" datetime="2020-12-23T21:01:18+08:00">2020-12-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          
            <div class="post-description">JS的东西挺多的，再加上JS的单线程会导致很多地方与其他的编程语言有一些实现上的不同，不过很多东西思想上还是差不多的，感觉 ES6 的文档看着就和看 JavaScript 的文档一样，填补了很多知识细节。2020 应届生找前端，邮件微信 QQ 联系我谢谢。这篇不更新了，太大了写起来都卡😒。分成小篇更新。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="前端资源"><a href="#前端资源" class="headerlink" title="前端资源"></a>前端资源</h1><p><a target="_blank" rel="noopener" href="https://www.gulpjs.com.cn/">gulp</a> 是一个 js 自动化工具。</p>
<p>github 上的一些资料</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/helloqingfeng/Awsome-Front-End-learning-resource">Awsome-Front-End-learning-resource</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.font.im/">谷歌字体</a></p>
<p><a target="_blank" rel="noopener" href="http://ogp.me/">Open Graph protocol</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn">MDN 学习 Web 开发</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/">掘金</a> 是真的挺不错的一个社区。好多干货文章。</p>
<p><a target="_blank" rel="noopener" href="https://zh.javascript.info/">现代 JavaScript 教程</a></p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e5339b46fb9a07cb83e20d4">一文完全吃透 JavaScript 继承(面试必备良药)</a></p>
<blockquote>
<p>这篇文章详细讲解了原型相关的知识，包括原型链、ES5 ES6 中的继承实现以及原理。帮助理解 JavaScript 面向对象方向的继承原理和构造器相关概念。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e535624518825496e784ccb">[译] 在 async/await 中更好的处理错误</a></p>
<blockquote>
<p>这篇文章详细介绍了在 JavaScript 中的异步问题，介绍了回调地狱、Promise、async/await，以及他们的错误处理机制。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e4c0b856fb9a07ccb7e8eca">中高级前端面试题（万字长文）</a></p>
<blockquote>
<p>面试题以及知识框架整理。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e53a6d3f265da571671080f">理解 Javascript 的正则表达式</a></p>
<blockquote>
<p>正则表达式是在应用中相当重要的一部分，需要去理解记忆并多加练习。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e50e5b16fb9a07c9a1959af">轻松理解 JS 中的面向对象，顺便搞懂 prototype 和<strong>proto</strong></a></p>
<blockquote>
<p>理解 JavaScript 中的原型、原型链、构造器等相关概念。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e532b116fb9a07ce152c31a">2020 年你不能不知道的 webpack 基本配置</a></p>
<blockquote>
<p>了解 webpack 工具，官方文档 <a target="_blank" rel="noopener" href="https://www.webpackjs.com/concepts/">https://www.webpackjs.com/concepts/</a></p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e50fa23518825494b3cccd7">前端下载文件的 5 种方法的对比</a></p>
<blockquote>
<p>关于前端的一些典型下载文件实现案例。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e4d24cce51d4526f76eb2ba">2020 年大厂面试指南 - Vue 篇</a></p>
<blockquote>
<p>看大厂面试题对于理解相关知识也是很有用的。重要的是不要死记硬背，因为很多答案并不是从原理讲起，或者讲了看不懂，需要结合官方文档和实际上手去理解。</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5e06b4666fb9a0164f2956c0">Vue 源码系列一：Vue 中的 data 是如何驱动视图渲染的？</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5e0dd467e51d45410f1232f5">VUE 源码系列二：Vue 响应式原理解析（附超详细源码注释和原理解析）</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5e1ae62b51882526b831f1cb">VUE 源码系列三：nextTick 原理解析（附源码解读）</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5e21619ce51d4552455a8896">VUE 源码系列四：计算属性和监听属性，到底该用谁？</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5e2804e1e51d453c9e155f08">VUE 源码系列五：组件是怎样生成的？(附详细源码解析)</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5e2cfd695188252c5232ae3b">VUE 源码系列六：编译原理</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5e3647816fb9a030133074b0">VUE 源码系列七：v-model 实现原理</a></li>
</ul>
<blockquote>
<p>非常感谢这位作者，关于 Vue 的实现原理可以参考上面的连载专栏。不需要去深入算法，但是需要去了解一些基本的原理。同时自己可以尝试做一个类似的例如双重绑定、响应式等等。</p>
<p>这个源码系列好多都没看懂， 只能看个大概。感觉文档越看越浮躁了。</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5e2f88156fb9a02fdd38a184">(1. 8w 字)负重前行，前端工程师如何系统练习数据结构和算法？【上】</a></li>
</ul>
<blockquote>
<p>作为计算机相关行业人员对于数据结构和算法是必须要掌握一些的。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5da282015188257d2a1c9e1d">剖析一些经典的 CSS 布局问题，为前端开发+面试保驾护航</a></p>
<blockquote>
<p>跟着某些作者看可以找到一些没有推荐过的文章。有的还没看过，先留着。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e57048b6fb9a07cc845a9ef">前端面试常考的手写代码不是背出来的！</a></p>
<blockquote>
<p>这篇文章是对于代码规范和一些功能函数的实例研究，很基础但也很有用。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e54d9e86fb9a07c944c932a">深入理解 JS 的原型和原型链</a></p>
<blockquote>
<p>深入理解原型和原型链之间的关系，然后引申出执行上下文和 this 的相关概念。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d153267e51d4510624f9809">vue 248 个知识点（面试题）为你保驾护航</a></p>
<blockquote>
<p>了解 Vue 的相关知识点和原理。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e4943d0f265da57537eaba9">🔥(已更新 3. 1w 字)《大前端吊打面试官系列》 之 ES6 精华篇（2020 年）</a></p>
<blockquote>
<p>深入理解 ES6 。</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5e5c65fc6fb9a07cd00d8838">4W 字长文带你深度解锁 Webpack 系列(上)</a></li>
</ul>
<blockquote>
<p>在前端开发环境下，对于 Webpack、gulp 等工具的理解使用对于提升开发效率、专注前端页面是有好处的。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e5c7f6c518825491b11ce93">面试题：说说事件循环机制(满分答案来了)</a></p>
<blockquote>
<p>关于事件循环机制。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e5b488af265da574112089f">前端工程师的自我修养-关于 Babel 那些事儿</a></p>
<blockquote>
<p>Babel 是可以对代码进行向后兼容性编译的编译器，使得代码在不同环境下依然可以稳定运行。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e578a5f518825494707e4bb">你再不知道怎么解决跨域, 我就真的生气了</a></p>
<blockquote>
<p>关于跨域相关的知识点。跨域指的是由于浏览器出于安全考虑所设置的同源策略，如果协议、域名、端口有一项不同就会产生跨域问题，而跨域问题所带来的是安全问题，解决跨域不仅仅是让前端可以成功访问到跨域资源，更重要的是理解背后的安全隐患。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e5ef2f9f265da57685dc9c1">记好这 24 个 ES6 方法，用来解决实际开发的 JS 问题</a></p>
<blockquote>
<p>ES6 相关的对于实际问题的解决办法。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e5b43b1f265da5716710e4c">深入 vue 响应式原理（包含 vue3. 0）</a></p>
<blockquote>
<p>看这个是想了解关于 Vue 2. 0 和 3. 0 之间的变化。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e3d898cf265da5732551a56">2020 前端面试 | 第一波面试题总结</a></p>
<blockquote>
<p>实际面试题。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e34d19de51d4558864b1d1f">🔥 动画：《大前端吊打面试官系列》 之原生 JavaScript 精华篇</a></p>
<blockquote>
<p>关于 JavaScript 相关的基础知识理解。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e575e02f265da573b0dad5f">前端也能学算法：由浅入深讲解贪心算法</a></p>
<blockquote>
<p>关于贪心算法的讲解。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e475829f265da57444ab10f">「 如何优雅的使用 VUE? 」不可不知的 VUE 实战技巧</a></p>
<blockquote>
<p>Vue 的实战技巧。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5de87444518825124c50cd36">2020 年了, 再不会 webpack 敲得代码就不香了(近万字实战)</a></p>
<blockquote>
<p>webpack 相关知识。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e58c618e51d4526ed66b5cf">【建议星星】要就来 45 道 Promise 面试题一次爽到底(1. 1w 字用心整理)</a></p>
<blockquote>
<p>关于 Promise 的各种面试题型。加深对于异步的理解和处理。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e5f52fce51d4526ea7efdec">从手写 Promise 到 async/await(接近 6 千字, 建议看一下)</a></p>
<blockquote>
<p>关于异步和生成器、构造器的原理讲解和一些组合方法。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e6358256fb9a07cd80f2e70">【建议 👍】再来 40 道 this 面试题酸爽继续(1. 2w 字用手整理)</a></p>
<blockquote>
<p>关于 this 的相关题型。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NTA4NTIwNA==&mid=2247484468&idx=1&sn=3c309945992fe4f0c6276d91d7cb67b8&chksm=ce5e364ff929bf59ae686e3fa2412632348d6e190054e0b83bed11b5fd851ebbe8d326b5caf0&token=1424393752&lang=zh_CN#rd">vue 组件通信看这篇就够了(12 种通信方式)</a></p>
<blockquote>
<p>详细介绍了不同的父子组件间的通信方式。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/59b73d5bf265da064618731d">学习 BFC (Block Formatting Context)</a></p>
<blockquote>
<p>了解在 CSS 中的 BFC 的相关概念。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA">【第 1250 期】彻底理解浏览器的缓存机制</a></p>
<blockquote>
<p>了解浏览器的缓存机制</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e57feede51d4526dd1ea7e9">【译】Async/await 和 Promise 的不为人知的秘密</a></p>
<blockquote>
<p>关于 Async 和 Promise 的性能上的区别。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/answershuto/learnVue">learnVue</a></p>
<blockquote>
<p>github 上的 Vue 学习文章</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d9c9a135188252e097569bd">Vue3 响应式系统源码解析-单测篇</a></p>
<blockquote>
<p>关于 Vue3 的响应式实现。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5cab0c45f265da2513734390">【面试篇】寒冬求职季之你必须要懂的原生 JS(上)</a></p>
<blockquote>
<p>经典面试题和解析</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5cbd1e33e51d45789161d053">【面试篇】寒冬求职季之你必须要懂的原生 JS(中)</a></p>
<blockquote>
<p>经典面试题和解析</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5cd6ad7a51882568d3670a8e">【面试篇】寒冬求职之你必须要懂的 Web 安全</a></p>
<blockquote>
<p>关于 Web 安全的相关面试题和解析</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d2036106fb9a07eb15d76e9">「进击的前端工程师」浏览器中 JavaScript 的事件循环</a></p>
<blockquote>
<p>深入了解 JavaScript 引擎的事件机制，后面的例题也很值得思考。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2975c25e4d71">详解 JS 函数柯里化</a></p>
<blockquote>
<p>介绍了柯里化的详细原理和实现过程</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b561426518825195f499772">柯里化与反柯里化</a></p>
<blockquote>
<p>详细解释柯里化的用法</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e8b261ae51d4546c0382ab4">2 万字 | 前端基础拾遗 90 问</a></p>
<blockquote>
<p>深入理解基础，大多都是需要去看代码思考代码的问题。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e91b01651882573716a9b23">一位前端小姐姐的五万字面试宝典</a></p>
<blockquote>
<p>经典例题以及代码实现</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/47407398">图解浏览器的基本工作原理</a></p>
<blockquote>
<p>了解浏览器的工作原理</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018428170">浅谈 js 防抖和节流</a></p>
<blockquote>
<p>了解防抖和节流的思想以及实现方法</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c8b86b09daf0">函数防抖和节流</a></p>
<blockquote>
<p>可以参考上面的文章一起看，我感觉这个实例代码写的更好一些。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5ce607a7e51d454f6f16eb3d">前端基础篇之 CSS 世界</a></p>
<blockquote>
<p>总算找到 CSS 的教程了。</p>
</blockquote>
<h1 id="知识框架"><a href="#知识框架" class="headerlink" title="知识框架"></a>知识框架</h1><ul>
<li>HTML<ul>
<li>HTML 不同版本的差异</li>
<li>HTML5</li>
</ul>
</li>
<li>CSS<ul>
<li>CSS 不同版本的差异</li>
<li>CSS3</li>
<li>Sass</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1022910821149312">JavaScript 廖雪峰</a><ul>
<li><a target="_blank" rel="noopener" href="https://www.tslang.cn/index.html">TypeScript</a></li>
</ul>
</li>
<li>Node. js</li>
<li>jQuery（老掉牙了）</li>
<li>Ajax（也老掉牙了，了解 XMR 就行）</li>
<li>Webpack</li>
<li>Gulp</li>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/">Vue</a></li>
<li><a target="_blank" rel="noopener" href="https://react.docschina.org/">React</a></li>
<li><a target="_blank" rel="noopener" href="https://angular.cn/">Angular</a></li>
<li>ES5</li>
<li>ES6</li>
</ul>
<h1 id="HTML-整理"><a href="#HTML-整理" class="headerlink" title="HTML 整理"></a>HTML 整理</h1><p>HTML 只是一个标记性的语言，本身没有什么学习难度，HTML5 是新一代的 HTML 标准，实现了一些新的元素和属性， 改进了本地存储并且添加了很多语义元素，使得代码或者页面更加语义化。语义化的好处在于对代码的理解更加简单，同时也为视力障碍人士改善了网页的可阅读性。</p>
<p>关于更多的细节参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/html/html-tutorial.html">https://www.runoob.com/html/html-tutorial.html</a></p>
<h2 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML DOM"></a>HTML DOM</h2><p>关于 DOM 的理解可以参考 <a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction</a></p>
<p>DOM 是文档对象模型的缩写，按照对对象的理解，DOM 就是浏览器生成的这个页面的对象，每一个 HTML 元素就是一个节点，通过 HTML 的嵌套关系生成子节点和父节点关系的树，元素的属性也是元素对应节点的子节点。</p>
<p>DOM 的树并不是普通的二叉树或者特殊的树</p>
<p><img src="https://www.w3school.com.cn/i/dom_navigate.gif" alt="DOM 节点关系"></p>
<p>关系其实还是挺复杂的。不过 DOM 提供了各种方法实现了对于节点或者元素的选择、修改。</p>
<p>获取目标元素节点是对于 JavaScript 脚本比较重要的一环，获取到节点后即可对节点所产生的事件进行脚本控制。</p>
<p>当然在 Vue 或者 React 等框架中有对应的方法可以更加方便的获取节点添加事件。</p>
<h3 id="CSS-DOM"><a href="#CSS-DOM" class="headerlink" title="CSS DOM"></a>CSS DOM</h3><p>css 也是有一个 DOM 树的通过将两棵树合并生成一个渲染树供浏览器对页面进行渲染。</p>
<h1 id="CSS-整理"><a href="#CSS-整理" class="headerlink" title="CSS 整理"></a>CSS 整理</h1><p>CSS 的作用是给 HTML 元素加上样式，同时又可以多个样式层叠，所以叫层叠样式表。</p>
<p>CSS 的内容也是比较复杂的。细节参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/css/css-tutorial.html">https://www.runoob.com/css/css-tutorial.html</a></p>
<p>需要理解不同元素类型能做的事和不能做的事，例如行内元素的宽度和高度是不能设置的。根据内容自动。</p>
<p>不过对于网页 CSS 设计来说，例如 Bootstrap 或者 Element 等前端组件库已经设定好了很多实用的样式。可以在此基础上进行自定义。关于页面的布局也是有对应的解决方案，需要理解的还是元素的类型，</p>
<p>参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/pr-class-display.html">https://www.runoob.com/cssref/pr-class-display.html</a></p>
<p>CSS 相关的教程好少啊，但是感觉各种属性对应的布局却很麻烦。</p>
<h2 id="关于各个布局"><a href="#关于各个布局" class="headerlink" title="关于各个布局"></a>关于各个布局</h2><p><a target="_blank" rel="noopener" href="https://zh.learnlayout.com/">https://zh.learnlayout.com/</a> 可以用来了解布局相关的知识。</p>
<p>布局其实就是把网页根据内容进行一个规划。</p>
<p>网页的内容永远都是不确定的，那么布局当然是要怎么好看怎么来。</p>
<p>了解布局首先需要了解 <code>display</code> 这个属性。这个属性决定了 HTML 元素在 CSS 层面上的性质。每个 tag 都有默认的 <code>display</code> 属性，比如常见的 <code>h1</code> <code>div</code> <code>p</code> <code>form </code> 就是块级元素，而 <code>a</code> <code>b</code> <code>i</code> <code>span</code> <code>select</code> <code>img</code> <code>input</code> 都是行内元素。</p>
<p>通过不同的元素特性，页面元素也会产生不同的显示效果。比如在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">弹性盒子</a>中有很多新的特性和 CSS 样式，可以更加方便快捷的设定垂直居中效果，而在块级元素中就很难做到。大致上来说网页的布局也就分为一列、二列、三列，通过样式的叠加形成不同的网页显示效果。至于说的什么圣飞布局、双飞翼布局感觉没啥意思，究其原理还是浮动、弹性盒子、网格、定位这类基础属性，只能说是别人设计出来的网页布局就是了。重要的还是内容的排列。通过 <code>display</code> 属性获得不同的文字、图片、内容块的排列效果。</p>
<h2 id="关于盒模型"><a href="#关于盒模型" class="headerlink" title="关于盒模型"></a>关于盒模型</h2><p>盒模型是用来计算元素大小的一个标准模型，完整适用于块元素，部分适用于行内元素。盒模型还有一个替代模型 IE 盒模型，在 IE 盒模型中，所有的宽度和高度都是可见的，内容的宽度包括了 Padding 的宽度。</p>
<p><img src="https://media.prod.mdn.mozit.cloud/attachments/2019/03/19/16558/29c6fe062e42a327fb549a081bc56632/box-model.png" alt="Diagram of the box model"></p>
<p>W3C 模型中的块级元素大小 = Content+Padding*2+Margin*2+Border*2</p>
<p>IE 盒模型大小不包括 Margin。</p>
<blockquote>
<p>一个被定义成块级的（block）盒子会表现出以下行为:</p>
<ul>
<li>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽</li>
<li>每个盒子都会换行</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"> <code>width</code> </a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"> <code>height</code> </a> 属性可以发挥作用</li>
<li>内边距（padding）, 外边距（margin） 和 边框（border） 会将其他元素从当前盒子周围“推开”</li>
</ul>
</blockquote>
<blockquote>
<p>如果一个盒子对外显示为 <code>inline</code> ，那么他的行为如下:</p>
<ul>
<li>盒子不会产生换行。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/width"> <code>width</code> </a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/height"> <code>height</code> </a> 属性将不起作用。</li>
<li>内边距、外边距以及边框会被应用但是不会把其他处于 <code>inline</code> 状态的盒子推开。</li>
</ul>
</blockquote>
<blockquote>
<p>一个元素使用 <code>display: inline-block</code> ，实现我们需要的块级的部分效果：</p>
<ul>
<li>设置 <code>width</code> 和 <code>height</code> 属性会生效。</li>
<li><code>padding</code> , <code>margin</code> , 以及 <code>border</code> 会推开其他元素。</li>
</ul>
<p>但是，它不会跳转到新行，如果显式添加 <code>width</code> 和 <code>height</code> 属性，它只会变得比其内容更大。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox">https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox</a> 详细介绍了 <code>display:flexible</code> 弹性盒子的 flex 模型</p>
<p><img src="https://developer.mozilla.org/files/3739/flex_terms.png" alt="flex_terms. png"></p>
<blockquote>
<ul>
<li><strong>主轴（main axis）</strong>是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 <strong>main start</strong> 和 <strong>main end</strong>。</li>
<li><strong>交叉轴（cross axis）</strong>是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 <strong>cross start</strong> 和 <strong>cross end</strong>。</li>
<li>设置了 <code>display: flex</code> 的父元素（在本例中是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/section"> <code>&lt;section&gt;</code> </a>）被称之为 <strong>flex 容器（flex container）。</strong></li>
<li>在 flex 容器中表现为柔性的盒子的元素被称之为 <strong>flex 项</strong>（<strong>flex item</strong>）（本例中是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/article"> <code>article</code> </a> 元素。</li>
</ul>
</blockquote>
<h2 id="CSS-语句的权重"><a href="#CSS-语句的权重" class="headerlink" title="CSS 语句的权重"></a>CSS 语句的权重</h2><p>css 选择器权重列表如下：</p>
<table>
<thead>
<tr>
<th>权重值</th>
<th>选择器</th>
</tr>
</thead>
<tbody><tr>
<td>1,0,0,0</td>
<td>内联样式：style=””</td>
</tr>
<tr>
<td>0,1,0,0</td>
<td>ID 选择器：<code>#idName&#123;...&#125;</code></td>
</tr>
<tr>
<td>0,0,1,0</td>
<td>类、伪类、属性选择器：<code>.className&#123;...&#125;</code> / <code>:hover&#123;...&#125;</code> / <code>[type=&quot;text&quot;] =&#123;...&#125;</code></td>
</tr>
<tr>
<td>0,0,0,1</td>
<td>标签、伪元素选择器：<code>div&#123;...&#125;</code> / <code>:after&#123;...&#125;</code></td>
</tr>
<tr>
<td>0,0,0,0</td>
<td>通用选择器（*）、子选择器（&gt;）、相邻选择器（+）、同胞选择器（~）</td>
</tr>
</tbody></table>
<p>需要注意的是这个权重并不是累加的，比如 ID 选择器会始终比属性选择器的优先级更高，即使在同一个元素上加 10 个属性选择器，优先级也不会比 ID 选择器高。系统在比较两个元素的优先级时会先比较高级的，如果相同才会向下比较，不相同就直接得出结果。</p>
<h2 id="垂直对齐"><a href="#垂直对齐" class="headerlink" title="垂直对齐"></a>垂直对齐</h2><p>行内元素在块级元素中的垂直对齐主要使用 <code>line-height</code> 和 <code>vertical-align</code> 两个属性。</p>
<p><code>line-height</code> 属性通过设置行高确定行距，行距是系统会自动设置上下对等的，所以将行高设置成块级元素的高即可使行内元素在块级元素中垂直居中。</p>
<p><code>line-height</code> 属性可以在块级元素中设置也可以在子元素中设置，并且按照最大值确定。</p>
<p><code>vertical-align</code> 属性只能作用于内联元素。考虑到内联元素就需要考虑到 <code>基线</code> ，基线是字体对齐的标准。</p>
<p>一个设置了<code>display: inline-block</code>的元素：</p>
<ol>
<li>如果元素内部没有内联元素，则该元素基线就是该元素下边缘；</li>
<li>如果元素设置了<code>overflow</code>为<code>hidden auto scroll</code>，则其基线就是该元素下边缘；</li>
<li>如果元素内部还有内联元素，则其基线就是内部最后一行内联元素的基线。</li>
</ol>
<p>需要注意的是 <code>vertical-align</code> 属性是基于行按照基线去对齐的，所以如果他需要对齐的父元素的高度并不是普通行高，是需要设置 <code>line-height</code> 的。也就是说大部分时候 <code>line-height</code> 属性就可以居中了，但是在视觉上可能没有那么居中，所以需要 <code>vertical-align</code> 来微调。</p>
<h2 id="关于-BFC"><a href="#关于-BFC" class="headerlink" title="关于 BFC"></a>关于 BFC</h2><h2 id="CSS3-更新了什么"><a href="#CSS3-更新了什么" class="headerlink" title="CSS3 更新了什么"></a>CSS3 更新了什么</h2><p>CSS3 被拆分为”模块”。旧规范已拆分成小块，还增加了新的。</p>
<p>一些最重要 CSS3 模块如下：</p>
<ul>
<li>选择器</li>
<li>盒模型</li>
<li>背景和边框</li>
<li>文字特效</li>
<li>2D/3D 转换</li>
<li>动画</li>
<li>多列布局</li>
<li>用户界面</li>
</ul>
<h3 id="新的边框属性"><a href="#新的边框属性" class="headerlink" title="新的边框属性"></a>新的边框属性</h3><p><code>border-radius</code> 可以为任何元素提供一个圆角，值一般是这个圆角的半径。可以单独为每个角进行设置。</p>
<p><code>box-shadow</code> 属性用于给一个元素添加阴影效果。这个元素可以是块元素也可以是内联元素。</p>
<p><code>border-image</code> 用于给边框提供一个自定义的图片。</p>
<h3 id="新的背景属性"><a href="#新的背景属性" class="headerlink" title="新的背景属性"></a>新的背景属性</h3><ul>
<li>background-image</li>
<li>background-size</li>
<li>background-origin</li>
<li>background-clip</li>
</ul>
<p><code>background-image</code> 属性可以同时使用多张图片，通过逗号隔开，其他的关于图片背景的设置会按照 <code>background-image</code> 中的引入顺序进行配置。</p>
<p><code>background-origin</code> 属性用于配置背景图片的位置是以 border、padding 还是 content 为起始位置。</p>
<p><code>background-clip</code> 属性和 <code>origin</code> 差不太多，只是作用不太一样，origin 是指定背景图片的位置，<code>clip</code> 是指定整个背景的范围。这里只用的裁剪，更适合用在纯色背景上。</p>
<h3 id="渐变效果（好看"><a href="#渐变效果（好看" class="headerlink" title="渐变效果（好看"></a>渐变效果（好看</h3><ul>
<li><strong>线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向</strong></li>
<li><strong>径向渐变（Radial Gradients）- 由它们的中心定义</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">direction</span>, <span class="selector-tag">color-stop1</span>, <span class="selector-tag">color-stop2</span>, ...);</span><br><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">radial-gradient</span>(</span><br><span class="line">  <span class="selector-tag">shape</span> <span class="selector-tag">size</span> <span class="selector-tag">at</span> <span class="selector-tag">position</span>,</span><br><span class="line">  <span class="selector-tag">start-color</span>,</span><br><span class="line">  ...,</span><br><span class="line">  <span class="selector-tag">last-color</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>默认情况下是从上到下的渐变。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/07/7B0CC41A-86DC-4E1B-8A69-A410E6764B91.jpg" alt="角度图"></p>
<p>也可以通过角度来设置方向。</p>
<p>（可以设置多个节点但是彩虹色好看吗？）</p>
<p>变化更多的话可以使用透明度，也就是使用 rgba() 函数来定义颜色节点。</p>
<p>径向渐变就是一个渐变圆，默认是一个椭圆，可以设置为圆形的渐变。</p>
<p>甚至可以通过 <code>repeating-radial-gradient() </code> 设置重复效果。或许可以用来做水滴波纹样式。</p>
<h3 id="新的文本属性"><a href="#新的文本属性" class="headerlink" title="新的文本属性"></a>新的文本属性</h3><ul>
<li>text-shadow</li>
<li>box-shadow</li>
<li>text-overflow</li>
<li>word-wrap</li>
<li>word-break</li>
</ul>
<h1 id="JavaScript-整理"><a href="#JavaScript-整理" class="headerlink" title="JavaScript 整理"></a>JavaScript 整理</h1><p>关于语法就和其他语言是一样的，变量、运算、数据类型、函数、对象、数组、循环、作用域等等。</p>
<p>不一样的是，由于 JavaScript 是运行在浏览器上的。所以很多功能代码都是已经实现了的。不需要像其他语言一样需要自己写类。由于本身是面向对象的，JavaScript 的所有变量都是一个对象。对于 JavaScript 的学习需要去了解背后的原理。</p>
<p>由于浏览器的版本大家可能都不一样，所以在使用 JavaScript 特性的时候需要考虑版本问题。了解 ES5 和 ES6 的区别。可以使用 <a target="_blank" rel="noopener" href="https://caniuse.com/">https://caniuse.com/</a> 来了解特性的支持情况。</p>
<p>细节参考 <a target="_blank" rel="noopener" href="https://www.w3school.com.cn/js/index.asp">https://www.w3school.com.cn/js/index.asp</a></p>
<h2 id="关于原型链"><a href="#关于原型链" class="headerlink" title="关于原型链"></a>关于原型链</h2><p>JavaScript 是解释型脚本语言，同时也是面向对象的语言，JavaScript 的对象是动态的属性“包”，会有一个 <code>__proto__</code> 的私有属性，该属性会指向构造函数的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让我们从一个自身拥有属性a和b的函数里创建一个对象o：</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">this</span>.b = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 这么写也一样</span></span><br><span class="line"><span class="comment">function f() &#123;</span></span><br><span class="line"><span class="comment">  this.a = 1;</span></span><br><span class="line"><span class="comment">  this.b = 2;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> f(); <span class="comment">// &#123;a: 1, b: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在f函数的原型上定义属性</span></span><br><span class="line">f.prototype.b = <span class="number">3</span>;</span><br><span class="line">f.prototype.c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要在 f 函数的原型上直接定义 f.prototype = &#123;b:3,c:4&#125;;这样会直接打破原型链</span></span><br><span class="line"><span class="comment">// o.[[Prototype]] 有属性 b 和 c</span></span><br><span class="line"><span class="comment">//  (其实就是 o.__proto__ 或者 o.constructor.prototype)</span></span><br><span class="line"><span class="comment">// o.[[Prototype]].[[Prototype]] 是 Object.prototype.</span></span><br><span class="line"><span class="comment">// 最后o.[[Prototype]].[[Prototype]].[[Prototype]]是null</span></span><br><span class="line"><span class="comment">// 这就是原型链的末尾，即 null，</span></span><br><span class="line"><span class="comment">// 根据定义，null 就是没有 [[Prototype]]。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 综上，整个原型链如下:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;a:1, b:2&#125; ---&gt; &#123;b:3, c:4&#125; ---&gt; Object.prototype---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// a是o的自身属性吗？是的，该属性的值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.b); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// b是o的自身属性吗？是的，该属性的值为 2</span></span><br><span class="line"><span class="comment">// 原型上也有一个&#x27;b&#x27;属性，但是它不会被访问到。</span></span><br><span class="line"><span class="comment">// 这种情况被称为&quot;属性遮蔽 (property shadowing)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.c); <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// c是o的自身属性吗？不是，那看看它的原型上有没有</span></span><br><span class="line"><span class="comment">// c是o.[[Prototype]]的属性吗？是的，该属性的值为 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.d); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// d 是 o 的自身属性吗？不是，那看看它的原型上有没有</span></span><br><span class="line"><span class="comment">// d 是 o.[[Prototype]] 的属性吗？不是，那看看它的原型上有没有</span></span><br><span class="line"><span class="comment">// o.[[Prototype]].[[Prototype]] 为 null，停止搜索</span></span><br><span class="line"><span class="comment">// 找不到 d 属性，返回 undefined</span></span><br></pre></td></tr></table></figure>
<p>来自 MDN <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain</a></p>
<p>所以当一个对象通过 <code>new</code> 关键字从其他的对象“实例化”，会将先生成一个空对象，通过 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">Object. setPrototypeOf()</a>原生函数将实例对象添加到原型链上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">polyNew</span>(<span class="params">source, ...arg</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的简单JavaScript对象（即&#123;&#125;）</span></span><br><span class="line">    <span class="keyword">let</span> newObj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 链接该对象（即设置该对象的构造函数）到另一个对象</span></span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf(newObj, source.prototype);</span><br><span class="line">    <span class="comment">// 将步骤1新创建的对象作为this的上下文 ；</span></span><br><span class="line">    <span class="keyword">const</span> resp = source.apply(newObj, arg);</span><br><span class="line">    <span class="comment">// 判断该函数返回值是否是对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(resp) === <span class="string">&quot;[object Object]&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果该函数没有返回对象，则返回this。</span></span><br><span class="line">        <span class="keyword">return</span> resp</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果该函数返回对象，那用返回的这个对象作为返回值。</span></span><br><span class="line">        <span class="keyword">return</span> newObj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者： dellyoung</span><br><span class="line">链接： https: <span class="comment">//juejin.im/post/5e54d9e86fb9a07c944c932a</span></span><br><span class="line">    来源： 掘金</span><br><span class="line">著作权归作者所有。 商业转载请联系作者获得授权， 非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>上面这个地址的文章写的非常详细。可以深入理解关于原型 Null 、原型链、This 的相关原理。</p>
<p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p>
<p>实现起来也是比较简单的。顺藤摸瓜就行了。</p>
<p><strong>this 是什么？</strong></p>
<p>理解 <strong>this</strong> 就需要理解 JavaScript 的执行上下文和调用栈，可以看上面的文章进行详细的步进的了解。</p>
<p>了解了执行上下文后，就知道了执行上下文包括了变量环境、词法环境、outer、this。</p>
<p>而这个 <code>this</code> 就是指向当下执行环境的一个指针。在浏览器环境下指的是 window。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">执行下面代码：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"><span class="comment">// 可以看到输出了window，说明在默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的。</span></span><br><span class="line"><span class="comment">// 可以认为 JavaScript 引擎在执行foo()时，将其转化为了：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.foo.call(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>
<p>关于这一段我理解的是由于 <code>foo()</code> 函数是一个函数而不是一个对象， <code>this</code> 指向这个函数没有什么意义，于是默认情况下会将它指向上一层的执行上下文<strong>对象</strong>即 <code>window</code> window 在浏览器中表示浏览器的窗口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">//Window &#123;parent: Window, opener: Window, top: Window, length: 0, frames: Window, …&#125;</span></span><br><span class="line">a = <span class="keyword">new</span> foo();</span><br><span class="line"><span class="comment">//foo &#123;&#125;</span></span><br><span class="line"><span class="comment">//    __proto__:</span></span><br><span class="line"><span class="comment">//        constructor: ƒ foo()</span></span><br><span class="line"><span class="comment">//        __proto__: Object</span></span><br></pre></td></tr></table></figure>
<p>可见，当我们把它实例化的时候，会通过 <code>new</code> 中的构造器，将 <code>foo()</code> 链接到 <code>a</code> 的原型上。这个时候的 <code>this</code> 指的就是 <code>foo()</code> 了，当然这个 <code>foo()</code> 并不是说 <code>foo()</code> 函数，而是指将 <code>foo()</code> 实例化的 <code>a</code> 对象。如果再实例化一个 <code>b </code> ，两者并不会相等。</p>
<p>或许我可以理解为 <strong>this 指代的永远是一个对象，而非一个函数，如果在函数中输出一个 this 而这个函数并非是某个对象的方法，那么 this 会重定向到 window 对象</strong></p>
<p>关于执行上下文还有配套的 <code>call</code> 、 <code>apply</code> 、 <code>bind</code> 三个方法。详情参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply#">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply#</a></p>
<p>主要用处就是设置 <code>this</code> ，在调用一个存在的函数时，你可以为其指定一个 <code>this</code> 对象。 <code>this</code> 指当前对象，也就是正在调用这个函数的对象。 使用 <code>apply</code> ， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>可以看到输出了 window，说明在<strong>默认情况</strong>下调用一个函数，其执行上下文中的 this 也是指向 window 对象的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">fn, x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;into&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        f(g, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;x&#x27;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">f(h, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// into</span></span><br><span class="line"><span class="comment">// into</span></span><br><span class="line"><span class="comment">// x0</span></span><br><span class="line"></span><br><span class="line">作者： 小黎也</span><br><span class="line">链接： https: <span class="comment">//juejin.im/post/5e523e726fb9a07c9a195a95</span></span><br><span class="line">    来源： 掘金</span><br><span class="line">著作权归作者所有。 商业转载请联系作者获得授权， 非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>这个面试题的逻辑看上去很简单，但是却有效的解释了执行上下文是如何影响程序的，同时也引出了作用域链的一个概念，上下文上下文，则说明是有上文也是有下文的。比如全局执行上下文就肯定是其他执行上下文的上文，那么参数在不同的执行上下文之间调用，每个参数不同的作用域，就形成了作用域链，和原型链是异曲同工的。如果一个函数在执行中找不到某个参数，就会顺着作用域链往上找。</p>
<p>g 函数中的 x 变量是引用父级的，而 f 函数执行了两次，x 变量依次为 0 1，在 f(h, 0) 这个函数执行的时候，这个函数的作用域中的 x=0，这个时候 g 函数中引用的 x 就是当前执行上下文中的 x=0 这个变量，但这个函数还没被执行，接着到了 f(g, 1) 执行，这一层执行上下文中的 x=1 ，但注意两次 f 执行的作用域不是同一个对象，是作用域链上两个独立的对象，最后到了 fn() ，这个 fn 是一个参数，也就是在 f(h, 0) 执行的时候 g 函数，那么 g 函数在这里被执行，g 打印出来的 x 就是 0 。</p>
<p>如果最后一段理解起来困难的话可以这样想，最后执行 f(g, 1)的时候，执行的 fn() 并不是当下的 g()，而是传入的 g()，而这个传入的 g() 是来自 f(h, 0) 这个环境下的。所以 x=0.</p>
<p>或许可以对这个题进行一个改变，如果 g() 函数的定义在是 f() 函数开头会怎么样？结果还是一样的，因为不管 g() 函数的位置如何变，始终是运行的 f(h, 0) 环境下的 g()。</p>
<h2 id="关于变量提升"><a href="#关于变量提升" class="headerlink" title="关于变量提升"></a>关于变量提升</h2><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting">https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting</a></p>
<p>变量提升（Hoisting）被认为是， Javascript 中执行上下文 （特别是创建和执行阶段）工作方式的一种认识。</p>
<p><strong>JavaScript 仅提升声明，而不提升初始化</strong>。</p>
<p>变量提升可能是个好东西，因为它能让你的程序跑起来。但也可能是个坏东西，因为会养成到处声明的坏习惯。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// Returns undefined</span></span><br><span class="line"><span class="keyword">var</span> num;</span><br><span class="line">num = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// If you declare the variable after it is used, but initialize it beforehand, it will return the value:</span></span><br><span class="line"></span><br><span class="line">num = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// returns 6</span></span><br><span class="line"><span class="keyword">var</span> num;</span><br></pre></td></tr></table></figure>
<p>正确的编写原则是先声明再初始化，最后才是运用变量。</p>
<p>在 ES6 中的 let 和 const 不存在变量提升</p>
<p>var: 解析器在对 js 解析时，会将脚本扫描一遍，将变量的声明提前到代码块的顶部，赋值还是在原先的位置，若在赋值前调用，就会出现暂时性死区，值为 <code>undefined</code></p>
<p>let const：不存在在变量提升，且作用域是存在于块级作用域下，所以这两个的出现解决了变量提升的问题，同时引用块级作用域。 注：变量提升的原因是为了解决函数互相调用的问题。</p>
<h2 id="关于-Promise-和-Async-Await"><a href="#关于-Promise-和-Async-Await" class="headerlink" title="关于 Promise 和 Async/Await"></a>关于 Promise 和 Async/Await</h2><p>在 MDN 中关于 Promise 是这样介绍的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises</a></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"> <code>Promise</code> </a> 是一个对象，它代表了一个异步操作的最终完成或者失败。本质上，Promise 是一个被某些函数传出的对象，我们附加回调函数（callback）使用它，而不是将回调函数传入那些函数内部。</p>
</blockquote>
<p>由于 JavaScript 是单线程的，所以我们需要考虑到网络的影响，如果在一个图片还没加载好的时候就去使用这个资源，是会造成图片缺失的，所以提出了异步，所谓异步就是使有关联性的程序按照顺序运行，防止资源加载未完成等问题。</p>
<p>我对于 <code>Promise</code> 的理解是，首先它的提出是为了解决回调函数过于复杂和冗余的问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">doSomething(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  doSomethingElse(</span><br><span class="line">    result,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">newResult</span>) </span>&#123;</span><br><span class="line">      doThirdThing(</span><br><span class="line">        newResult,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">finalResult</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;Got the final result: &quot;</span> + finalResult);</span><br><span class="line">        &#125;,</span><br><span class="line">        failureCallback</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">    failureCallback</span><br><span class="line">  );</span><br><span class="line">&#125;, failureCallback);</span><br></pre></td></tr></table></figure>
<p>回调函数本身是把一个函数作为另一个函数的参数，然后在函数中调用这个函数达到异步的效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">doSomething()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doSomethingElse(result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">newResult</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doThirdThing(newResult);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">finalResult</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Got the final result: &quot;</span> + finalResult);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(failureCallback);</span><br></pre></td></tr></table></figure>
<p>这个示例通过返回 Promise 对象，实现了 Promise 对象的 <code>then</code> 链式写法，then 里的参数是可选的， <code>catch(failureCallback)</code> 是 <code>then(null, failureCallback)</code> 的缩略形式。如下所示，我们也可以用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>来表示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">doSomething()</span><br><span class="line">  .then(<span class="function">(<span class="params">result</span>) =&gt;</span> doSomethingElse(result))</span><br><span class="line">  .then(<span class="function">(<span class="params">newResult</span>) =&gt;</span> doThirdThing(newResult))</span><br><span class="line">  .then(<span class="function">(<span class="params">finalResult</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Got the final result: <span class="subst">$&#123;finalResult&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(failureCallback);</span><br></pre></td></tr></table></figure>
<p>上面的示例来自 MDN 的 Promise 文档</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises</a></p>
<p>需要注意的是，这个示例并不能在 console 中跑起来，因为没有具体的定义 doSomething()，在实际使用中，这几个函数都是需要有返回值的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line">    resolve(<span class="string">&quot;doSomething end&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> doSomethingElse = <span class="function">(<span class="params">argu</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(argu);</span><br><span class="line">    resolve(<span class="string">&quot;doSomethingElse end&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> doThirdThing = <span class="function">(<span class="params">argu</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(argu);</span><br><span class="line">    resolve(<span class="string">&quot;doThirdThing end&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// doSomething()</span></span><br><span class="line"><span class="comment">// .then(result =&gt; doSomethingElse(result))</span></span><br><span class="line"><span class="comment">// .then(newResult =&gt; doThirdThing(newResult))</span></span><br><span class="line"><span class="comment">// .then(finalResult =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log( `Got the final result: $&#123;finalResult&#125;` );</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// .catch(()=&gt;&#123;console.log(&quot;fail&quot;)&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// doSomething</span></span><br><span class="line"><span class="comment">// doSomething end</span></span><br><span class="line"><span class="comment">// doSomethingElse end</span></span><br><span class="line"><span class="comment">// Got the final result: doThirdThing end</span></span><br><span class="line"><span class="comment">// Promise &#123;&lt;resolved&gt;: undefined&#125;</span></span><br></pre></td></tr></table></figure>
<p>当一个函数返回 Promise 对象的时候，可以把它当做一个异步函数，后面的 <code>.then</code> 方法是 Promise 对象的方法之一，用来接收上一个 Promise 在 resolve 的时候的消息，作为自定义的变量如 result 参与 <code>.then</code> 方法中的程序。由于几个函数都是返回的 Promise 对象，形成了一条 Promise 链。这条链是按照顺序异步运行的。 <code>.catch</code> 方法是用来获取在前面 Promise 链中的错误，进行合适的错误抛出和处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line"></span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;有哪里不对了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;执行「这个」”&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;执行「那个」&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;执行「这个」，无论前面发生了什么&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// 执行“那个”</span></span><br><span class="line"><span class="comment">// 执行“这个”，无论前面发生了什么</span></span><br></pre></td></tr></table></figure>
<p><code>.catch</code> 也是返回的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch">Promise 对象</a>，可以继续连接 <code>.then</code> 方法，使得程序在接收到错误后可以继续正常运行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> doSomething();</span><br><span class="line">    <span class="keyword">let</span> newResult = <span class="keyword">await</span> doSomethingElse(result);</span><br><span class="line">    <span class="keyword">let</span> finalResult = <span class="keyword">await</span> doThirdThing(newResult);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Got the final result: <span class="subst">$&#123;finalResult&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    failureCallback(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Async/Await 同样可以达成异步操作，并且代码看上去更加的简洁。Async/Await 其实是 Promise 的一个语法糖，其原理还是 Promise，</p>
<blockquote>
<p><code>async</code> / <code>await</code> 的目的是简化使用多个 promise 时的同步行为，并对一组 <code>Promises</code> 执行某些操作。正如 <code>Promises</code> 类似于结构化回调， <code>async</code> / <code>await</code> 更像结合了 generators 和 promises。</p>
</blockquote>
<p>关于 Async/Await 的错误处理机制可以参考 <a target="_blank" rel="noopener" href="https://juejin.im/post/5e535624518825496e784ccb">https://juejin.im/post/5e535624518825496e784ccb</a></p>
<p>继续深入一下 Promise</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"> <code>Promise.all()</code> </a></li>
</ul>
<blockquote>
<p>**<code>Promise.all(iterable)</code>**方法返回一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"> <code>Promise</code> </a> 实例，此实例在 <code>iterable</code> 参数内所有的 <code>promise</code> 都“完成（resolved）”或参数中不包含 <code>promise</code> 时回调完成（resolve）；如果参数中 <code>promise</code> 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 <code>promise</code> 的结果。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="number">1337</span>;</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values); <span class="comment">// [3, 1337, &quot;foo&quot;]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"> <code>Promise.allSettled()</code> </a></li>
</ul>
<blockquote>
<p>该**<code>Promise.allSettled()</code>**方法返回一个在所有给定的 promise 已被决议或被拒绝后决议的 promise，并带有一个对象数组，每个对象表示对应的 promise 结果。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(reject, <span class="number">100</span>, <span class="string">&quot;foo&quot;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> promises = [promise1, promise2];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled(promises).then(<span class="function">(<span class="params">results</span>) =&gt;</span></span><br><span class="line">  results.forEach(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result.status))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// expected output:</span></span><br><span class="line"><span class="comment">// &quot;fulfilled&quot;</span></span><br><span class="line"><span class="comment">// &quot;rejected&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"> <code>Promise.any()</code> </a></li>
</ul>
<blockquote>
<p><code>Promise.any()</code> 接收一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"> <code>Promise</code> </a>可迭代对象，只要其中的一个 <code>promise</code> 完成，就返回那个已经有完成值的 <code>promise</code> 。如果可迭代对象中没有一个 <code>promise</code> 完成（即所有的 <code>promises</code> 都失败/拒绝），就返回一个拒绝的 <code>promise</code> ，返回值还有待商榷：无非是拒绝原因数组或 <code>AggregateError</code> 类型的实例，它是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error"> <code>Error</code> </a> 的一个子类，用于把单一的错误集合在一起。本质上，这个方法和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"> <code>Promise.all()</code> </a>是相反的。</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"> <code>Promise.prototype.catch()</code> </a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally"> <code>Promise.prototype.finally()</code> </a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"> <code>Promise.prototype.then()</code> </a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"> <code>Promise.race()</code> </a></li>
</ul>
<blockquote>
<p><strong><code>Promise.race(iterable)</code></strong> 方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([promise1, promise2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="comment">// Both resolve, but promise2 is faster</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// expected output: &quot;two&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject"> <code>Promise.reject()</code> </a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"> <code>Promise.resolve()</code> </a></p>
</li>
</ul>
<p>Promise 对象的所有方法就是这些了。</p>
<p>理解 Async/Await 除了理解 Promise 之外，我们知道它是 Promise 的一个语法糖。结合了 Promise 和 constructor。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction#AsyncFunction_%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1">AsyncFunction</a> 就是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function"> <code>Async/Await</code> </a> 的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAfter2Seconds</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> AsyncFunction = <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;).constructor;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> AsyncFunction(</span><br><span class="line">  <span class="string">&quot;a&quot;</span>,</span><br><span class="line">  <span class="string">&quot;b&quot;</span>,</span><br><span class="line">  <span class="string">&quot;return await resolveAfter2Seconds(a) + await resolveAfter2Seconds(b);&quot;</span></span><br><span class="line">);</span><br><span class="line">a(<span class="number">10</span>, <span class="number">20</span>).then(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// 4 秒后打印 30</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个就是使用 AsyncFunction 实现的一个异步函数。不过看上去好像跟普通的 Promise 没什么不同，我记得看过一个实现 Async 构造器的文章，<del>找不到了。回头再写这里吧。</del></p>
<h2 id="关于包装对象"><a href="#关于包装对象" class="headerlink" title="关于包装对象"></a>关于包装对象</h2><p>在 JavaScript 中变量一般分为基本数据类型和对象类型。基本数据类型包括 Number、String、Boolean，在我们定义一个数字或者字符串的时候，它的类型 <code>typeof()</code> 出来就是普通的数据类型，但是我们可以使用 <code>.length</code> <code>.toString()</code> 等对象的方法，原因是 JavaScript 在执行的时候会使用数据类型对象包装原始数据，使其成为一个对象然后使用相关方法和属性。但是在输出后就会将其销毁，并不会改变原生数据的类型。</p>
<h2 id="关于-Null-和-Undefined"><a href="#关于-Null-和-Undefined" class="headerlink" title="关于 Null 和 Undefined"></a>关于 Null 和 Undefined</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span>;</span><br><span class="line"><span class="literal">true</span>;</span><br><span class="line"><span class="literal">undefined</span> === <span class="literal">null</span>;</span><br><span class="line"><span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>两个数据类型都是表示为空，但是具体的含义不太一样，Null 表示数据有值，值的内容为空，这个空并不是 0 或者一个空字符串，所以可以使用 Null 来初始化变量，Undefined 表示数据没有值，当变量仅被声明而没有被初始化的时候即是 Undefined。</p>
<p>经典一点的问题比如一个空数组，如何判定为空，由于 JavaScript 的对象类型，数组是对象的一种，他的原型是 Array 原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [];</span><br><span class="line"><span class="keyword">typeof</span> a;</span><br><span class="line">(<span class="string">&quot;object&quot;</span>);</span><br><span class="line">a === <span class="literal">null</span>;</span><br><span class="line"><span class="literal">false</span>;</span><br><span class="line">a == <span class="literal">null</span>;</span><br><span class="line"><span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>需要使用原型对象的 <code>.length</code> 属性来判断数组中是否有值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>](<span class="number">3</span>)[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)];</span><br><span class="line">a.length;</span><br><span class="line"><span class="number">3</span>;</span><br><span class="line">a.length = <span class="number">4</span>;</span><br><span class="line"><span class="number">4</span>;</span><br><span class="line">a(<span class="number">4</span>)[(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, empty)];</span><br></pre></td></tr></table></figure>
<h2 id="关于-JavaScript-执行机制和事件循环机制"><a href="#关于-JavaScript-执行机制和事件循环机制" class="headerlink" title="关于 JavaScript 执行机制和事件循环机制"></a>关于 JavaScript 执行机制和事件循环机制</h2><p>JavaScript 引擎是 JavaScript 的解释器，类似于 Python，他们都是解释性语言。JavaScript 在最初被开发出来时，是为了用于浏览器的，所以注定了 JavaScript 是一个单线程的语言。那么当 JavaScript 需要处理两个事件的时候，如果一个事件是一个需要等待的事件，那么他会挂起等待的任务，先运行后面的任务。</p>
<img src="/images/16bc675a7df7428e.png" class="img">

<p>这张图说明了，在主线程运行的时候，会生成堆栈，形成一个任务队列，然后主线程会循环访问这个任务队列，运行队列中的事件。</p>
<p>在堆中保存的是对象的数据，在栈中保存的是基本数据类型和函数执行时的内存信息。</p>
<blockquote>
<p>栈中的代码会调用各种外部 API，它们在任务队列中加入各种事件(onClick, onLoad, onDone)，只要栈中的代码执行完毕(js 引擎存在 <code>monitoring process</code> 进程，会持续不断的检查主线程执行栈是否为空)，主线程就回去读取任务队列，在按顺序执行这些事件对应的回调函数。</p>
<p>也就是说主线程从任务队列中读取事件，这个过程是循环不断的，所以这种运行机制又成为 <code>Event Loop</code> (事件循环)。</p>
<p>作者：童欧巴<br>链接：<a target="_blank" rel="noopener" href="https://juejin.im/post/5d2036106fb9a07eb15d76e9">https://juejin.im/post/5d2036106fb9a07eb15d76e9</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>通常来说，大部分的代码按照从上到下的顺序执行，并不会有什么问题，即是同步任务，但是当遇到例如加载图片这种操作的时候，可能在图片还没加载完成的情况下就使用了该图片，就会造成显示不全等问题，所以提出了<strong>异步</strong> 的思想。</p>
<p>同步任务就是在主线程上排队执行的任务，严格按照代码顺序执行（变量提升后），异步任务则不进入主线程，会在 event table 中注册函数，当达到执行条件后才会进入任务队列，然后在任务队列等待主线程执行。</p>
<p><strong>宏任务和微任务</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">	console.log(&#39;a&#39;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve) &#123;</span><br><span class="line">	console.log(&#39;b&#39;);</span><br><span class="line"></span><br><span class="line">	for(var i &#x3D;0; i &lt;10000; i++) &#123;</span><br><span class="line">		i &#x3D;&#x3D;99 &amp;&amp; resolve();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then(function() &#123;</span><br><span class="line">	console.log(&#39;c&#39;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#39;d&#39;);</span><br><span class="line">&#x2F;&#x2F; b</span><br><span class="line">&#x2F;&#x2F; d</span><br><span class="line">&#x2F;&#x2F; c</span><br><span class="line">&#x2F;&#x2F; a</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><p>首先执行 <code>script</code> 下的宏任务，遇到 <code>setTimeout</code> ，将其放入宏任务的队列里。</p>
</li>
<li><p>遇到 <code>Promise</code> ， <code>new Promise</code> 直接执行，打印 b。</p>
</li>
<li><p>遇到 <code>then</code> 方法，是微任务，将其放到微任务的队列里。</p>
</li>
<li><p>遇到 <code>console.log(&#39;d&#39;)</code> ，直接打印。</p>
</li>
<li><p>本轮宏任务执行完毕，查看微任务，发现 <code>then</code> 方法里的函数，打印 c。</p>
</li>
<li><p>本轮 <code>event loop</code> 全部完成。</p>
</li>
<li><p>下一轮循环，先执行宏任务，发现宏任务队列中有一个 <code>setTimeout</code> ，打印 a。</p>
</li>
</ol>
<p>作者：童欧巴<br>链接：<a target="_blank" rel="noopener" href="https://juejin.im/post/5d2036106fb9a07eb15d76e9">https://juejin.im/post/5d2036106fb9a07eb15d76e9</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<img src="/images/16bc6bd331a2116a.png" class="img">

<p>通过宏任务和微任务的划分, 可以更加清晰的分辨出程序的运行顺序,</p>
<p>上面的文章里还有一个思考题。推荐看一看。同时也看看 <a target="_blank" rel="noopener" href="https://juejin.im/post/5e5c7f6c518825491b11ce93">https://juejin.im/post/5e5c7f6c518825491b11ce93</a> 文章的理解，这篇文章更加详细，但是不太好懂。</p>
<h2 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h2><blockquote>
<p>函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起构成<strong>闭包</strong>（<strong>closure</strong>）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。</p>
</blockquote>
<p>也就是说闭包的作用是将一个构造函数的环境封闭，内部函数可以访问当前构造函数的变量，这个是很容易理解的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;Mozilla&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> displayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFunc = makeFunc();</span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure>
<p>运行这段代码的效果和之前 <code>init()</code> 函数的示例完全一样。其中不同的地方（也是有意思的地方）在于内部函数 <code>displayName()</code> _在执行前_，从外部函数返回。</p>
<p>原因在于，JavaScript 中的函数会形成了闭包。 <em>闭包</em>是由函数以及声明该函数的词法环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。在本例子中， <code>myFunc</code> 是执行 <code>makeFunc</code> 时创建的 <code>displayName</code> 函数实例的引用。 <code>displayName</code> 的实例维持了一个对它的词法环境（变量 <code>name</code> 存在于其中）的引用。因此，当 <code>myFunc</code> 被调用时，变量 <code>name</code> 仍然可用，其值 <code>Mozilla</code> 就被传递到 <code>alert</code> 中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>)); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">2</span>)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了 <code>makeAdder(x)</code> 函数，它接受一个参数 <code>x</code> ，并返回一个新的函数。返回的函数接受一个参数 <code>y</code> ，并返回 <code>x+y</code> 的值。</p>
<p>从本质上讲， <code>makeAdder</code> 是一个函数工厂 — 他创建了将指定的值和它的参数相加求和的函数。在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。</p>
<p><code>add5</code> 和 <code>add10</code> 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在 <code>add5</code> 的环境中， <code>x</code> 为 5。而在 <code>add10</code> 中， <code>x</code> 则为 10。</p>
<h3 id="用闭包模拟私有方法"><a href="#用闭包模拟私有方法" class="headerlink" title="用闭包模拟私有方法"></a>用闭包模拟私有方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Counter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 0 */</span></span><br><span class="line">Counter.increment();</span><br><span class="line">Counter.increment();</span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 2 */</span></span><br><span class="line">Counter.decrement();</span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 1 */</span></span><br><span class="line"><span class="keyword">var</span> makeCounter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Counter1 = makeCounter();</span><br><span class="line"><span class="keyword">var</span> Counter2 = makeCounter();</span><br><span class="line"><span class="built_in">console</span>.log(Counter1.value()); <span class="comment">/* logs 0 */</span></span><br><span class="line">Counter1.increment();</span><br><span class="line">Counter1.increment();</span><br><span class="line"><span class="built_in">console</span>.log(Counter1.value()); <span class="comment">/* logs 2 */</span></span><br><span class="line">Counter1.decrement();</span><br><span class="line"><span class="built_in">console</span>.log(Counter1.value()); <span class="comment">/* logs 1 */</span></span><br><span class="line"><span class="built_in">console</span>.log(Counter2.value()); <span class="comment">/* logs 0 */</span></span><br></pre></td></tr></table></figure>
<p>两个计数器具有独立性，引用的自己的词法作用域内的变量。与此同时并不能通过两个实例去访问私有属性和方法。</p>
<h2 id="JavaScript-的面向对象"><a href="#JavaScript-的面向对象" class="headerlink" title="JavaScript 的面向对象"></a>JavaScript 的面向对象</h2><p>面向对象三大特征：继承、多态、封装</p>
<p>当代码 <code>new Foo(...)</code> 执行时，会发生以下事情：</p>
<p>1. 一个继承自 <code>Foo\.prototype</code> 的新对象被创建。<br>2. 使用指定的参数调用构造函数 * <code>Foo</code> *，并将 <code>this</code> 绑定到新创建的对象。 <code>new Foo</code> 等同于 * <code>new Foo</code> * <code>\(\)</code> ，也就是没有指定参数列表，* <code>Foo</code> * 不带任何参数调用的情况。<br>3. 由构造函数返回的对象就是 <code>new</code> 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤 1 创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">func, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;; <span class="comment">// 新建一个空对象</span></span><br><span class="line">    <span class="keyword">const</span> result = func.call(obj, ...args); <span class="comment">// 执行构造函数</span></span><br><span class="line">    obj.__proto__ = func.prototype; <span class="comment">// 设置原型链</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意如果原构造函数有Object类型的返回值，包括Functoin, Array, Date, RegExg, Error</span></span><br><span class="line">    <span class="comment">// 那么应该返回这个返回值</span></span><br><span class="line">    <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> &amp;&amp; result !== <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> isFunction = <span class="keyword">typeof</span> result === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (isObject || isFunction) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原构造函数没有Object类型的返回值，返回我们的新对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Puppy</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.puppyAge = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Puppy.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;汪汪汪&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myPuppy3 = myNew(Puppy, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myPuppy3.puppyAge); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(myPuppy3.say()); <span class="comment">// 汪汪汪</span></span><br><span class="line"></span><br><span class="line">作者： 蒋鹏飞</span><br><span class="line">链接： https: <span class="comment">//juejin.im/post/5e50e5b16fb9a07c9a1959af</span></span><br><span class="line">    来源： 掘金</span><br><span class="line">著作权归作者所有。 商业转载请联系作者获得授权， 非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>ES6 中可以直接使用 <code>class</code> 关键字表示一个类，ES5 中则是使用函数对象和原型上的内置方法实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;Polygon&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> poly1 = <span class="keyword">new</span> Polygon();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(poly1.name);</span><br><span class="line"><span class="comment">// expected output: &quot;Polygon&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果不指定构造方法，则使用默认构造函数。对于基类，默认构造函数是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>对于派生类，默认构造函数是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>super</code> 不仅仅是一个标识符表示当前对象的父对象，当它作为一个函数的时候则代表父对象的构造函数。</p>
<p>通过 <code>extends</code> 命令声明该类是父类的子类。如果使用了 <code>extends</code> 就必须使用 <code>super()</code> 在构造函数中初始化父类。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Here, it calls the parent class&#x27; constructor with lengths</span></span><br><span class="line">    <span class="comment">// provided for the Polygon&#x27;s width and height</span></span><br><span class="line">    <span class="built_in">super</span>(length, length);</span><br><span class="line">    <span class="comment">// Note: In derived classes, super() must be called before you</span></span><br><span class="line">    <span class="comment">// can use &#x27;this&#x27;. Leaving this out will cause a reference error.</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;Square&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前的原型链中说过，构造函数是实现继承关系的，在构造函数内部会将两个类通过原型链链接。</p>
<p>参考 <a target="_blank" rel="noopener" href="https://juejin.im/post/5a96d78ef265da4e9311b4d8">https://juejin.im/post/5a96d78ef265da4e9311b4d8</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">a = <span class="string">&quot;a&quot;</span>, b = <span class="string">&quot;b&quot;</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">    <span class="built_in">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">methodA</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;父类方法A&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FatherFun</span>(<span class="params">a = <span class="string">&quot;a&quot;</span>, b = <span class="string">&quot;b&quot;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = a;</span><br><span class="line">  <span class="built_in">this</span>.b = b;</span><br><span class="line">  FatherFun.prototype.methodA = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;父类方法A&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链继承，通过new父类生成一个实例，将这个实例作为子类的原型。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.c = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">  <span class="comment">// 这里prototype不管用，不能继承到父类的属性和方法。</span></span><br><span class="line">  <span class="comment">// this.prototype = new FatherFun()</span></span><br><span class="line">  <span class="comment">// 原型方法和属性查询是通过 __proto__ 向上查询的。</span></span><br><span class="line">  <span class="built_in">this</span>.__proto__ = <span class="keyword">new</span> FatherFun();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> son1 = <span class="keyword">new</span> son();</span><br><span class="line"><span class="built_in">console</span>.log(son1.a);</span><br><span class="line">son1.methodA();</span><br><span class="line"><span class="comment">// son &#123;c: &quot;c&quot;&#125;</span></span><br><span class="line"><span class="comment">//     c: &quot;c&quot;</span></span><br><span class="line"><span class="comment">//     __proto__: FatherFun</span></span><br><span class="line"><span class="comment">//         a: &quot;a&quot;</span></span><br><span class="line"><span class="comment">//         b: &quot;b&quot;</span></span><br><span class="line"><span class="comment">//         __proto__:</span></span><br><span class="line"><span class="comment">//             methodA: ƒ ()</span></span><br><span class="line"><span class="comment">//             constructor: ƒ FatherFun(a = &#x27;a&#x27;, b = &#x27;b&#x27;)</span></span><br><span class="line"><span class="comment">//             __proto__: Object</span></span><br><span class="line"><span class="comment">// 也就是说原型链继承就是通过new方法继承。</span></span><br><span class="line"><span class="comment">// new 方法的实现原理如下</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">polyNew</span>(<span class="params">source, ...arg</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空的简单JavaScript对象（即&#123;&#125;）</span></span><br><span class="line">  <span class="keyword">let</span> newObj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 链接该对象（即设置该对象的构造函数）到另一个对象</span></span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(newObj, source.prototype);</span><br><span class="line">  <span class="comment">// 将步骤1新创建的对象作为this的上下文 ；</span></span><br><span class="line">  <span class="keyword">const</span> resp = source.apply(newObj, arg);</span><br><span class="line">  <span class="comment">// 判断该函数返回值是否是对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(resp) === <span class="string">&quot;[object Object]&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果该函数返回对象，那用返回的这个对象作为返回值。</span></span><br><span class="line">    <span class="keyword">return</span> resp;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果该函数没有返回对象，则返回newObj。</span></span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造继承</span></span><br><span class="line"><span class="comment">// function constrSon() &#123;</span></span><br><span class="line"><span class="comment">//     Father.call(this, &#x27;a&#x27;, &#x27;b&#x27;)</span></span><br><span class="line"><span class="comment">//     this.c = &#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// ES6 环境下会报错 TypeError: Class constructor Father cannot be invoked without &#x27;new&#x27;</span></span><br><span class="line"><span class="comment">// 这是因为 Father 通过 class 定义，构造函数需要通过 new 方法调用。如果使用原来的function对象方法构造即可。</span></span><br><span class="line"><span class="comment">// 也就是说ES6环境其实已经没有构造继承了（大概。</span></span><br><span class="line"><span class="comment">// 用.call()和.apply()将父类构造函数引入子类函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constrSon</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  FatherFun.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.c = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> constrSon1 = <span class="keyword">new</span> constrSon();</span><br><span class="line"><span class="built_in">console</span>.log(constrSon1.a);</span><br><span class="line"><span class="built_in">console</span>.log(constrSon1.c);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  constrSon1.methodA();</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// constrSon &#123;a: &quot;a&quot;, b: &quot;b&quot;, c: &quot;c&quot;&#125;</span></span><br><span class="line"><span class="comment">//     a: &quot;a&quot;</span></span><br><span class="line"><span class="comment">//     b: &quot;b&quot;</span></span><br><span class="line"><span class="comment">//     c: &quot;c&quot;</span></span><br><span class="line"><span class="comment">//     __proto__:</span></span><br><span class="line"><span class="comment">//         constructor: ƒ constrSon()</span></span><br><span class="line"><span class="comment">//         __proto__: Object</span></span><br><span class="line"><span class="comment">// 通过call方法可以将父类的构造方法用于子类，使得子类拥有父类的构造属性，但是不能调用父类的原型方法。同样也不能实现函数复用，每个子类都有父类实例函数的副本</span></span><br><span class="line"><span class="comment">// 实例属性指的是在构造函数中定义的属性和方法，每个实例对象都会单独保存；原型属性就是通过实例对象的构造函数的原型的属性和方法，实例对象共享。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://juejin.im/post/5e91b01651882573716a9b23 这里小姐姐说的实例继承不知道是个啥。看样子大概是寄生继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mistSon</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> o = <span class="built_in">Object</span>.create(<span class="keyword">new</span> Father());</span><br><span class="line">  <span class="comment">// Object.create() 方法中需要传入一个对象而不是一个类。</span></span><br><span class="line">  <span class="comment">// let o = Object.create(Father.prototype)</span></span><br><span class="line">  <span class="comment">// 使用 Father.prototype 会跳过构造器，不能访问到原型的原型属性，但是可以访问到方法。</span></span><br><span class="line">  o.__proto__.methodB = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;B方法&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mistSon1 = mistSon();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(mistSon1.a);</span><br><span class="line">  mistSon1.methodA();</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;</span><br><span class="line">mistSon1.methodB();</span><br><span class="line"><span class="comment">// mistSon1</span></span><br><span class="line"><span class="comment">// Father &#123;&#125;</span></span><br><span class="line"><span class="comment">//     __proto__: Father</span></span><br><span class="line"><span class="comment">//         a: &quot;a&quot;</span></span><br><span class="line"><span class="comment">//         b: &quot;b&quot;</span></span><br><span class="line"><span class="comment">//         methodB: ƒ ()</span></span><br><span class="line"><span class="comment">//         __proto__: Object</span></span><br><span class="line"><span class="comment">//             constructor: class Father</span></span><br><span class="line"><span class="comment">//             methodA: ƒ methodA()</span></span><br><span class="line"><span class="comment">//             __proto__: Object</span></span><br><span class="line"><span class="comment">// 从结果看来寄生继承实际就是父类的一个实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类继承+构造继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combinSon</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里用的是函数定义的类</span></span><br><span class="line">  FatherFun.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.c = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">combinSon.prototype = <span class="keyword">new</span> FatherFun();</span><br><span class="line"><span class="keyword">let</span> combinSon1 = <span class="keyword">new</span> combinSon();</span><br><span class="line"><span class="built_in">console</span>.log(combinSon1.a);</span><br><span class="line">combinSon1.methodA();</span><br><span class="line"><span class="comment">// combinSon &#123;a: &quot;a&quot;, b: &quot;b&quot;, c: &quot;c&quot;&#125;</span></span><br><span class="line"><span class="comment">//     a: &quot;a&quot;</span></span><br><span class="line"><span class="comment">//     b: &quot;b&quot;</span></span><br><span class="line"><span class="comment">//     c: &quot;c&quot;</span></span><br><span class="line"><span class="comment">//     __proto__: FatherFun</span></span><br><span class="line"><span class="comment">//         a: &quot;a&quot;</span></span><br><span class="line"><span class="comment">//         b: &quot;b&quot;</span></span><br><span class="line"><span class="comment">//         __proto__: Object</span></span><br><span class="line"><span class="comment">//             methodA: ƒ ()</span></span><br><span class="line"><span class="comment">//             constructor: ƒ FatherFun(a = &#x27;a&#x27;, b = &#x27;b&#x27;)</span></span><br><span class="line"><span class="comment">//             __proto__: Object</span></span><br><span class="line"><span class="comment">// 原型上依然是有父类的属性存在。</span></span><br><span class="line"><span class="comment">// 通过new父类赋值给子类的原型形成原型链</span></span><br><span class="line"><span class="comment">// 再实例化子类，这样的子类实例可以访问父类的原型方法。而且父类的构造函数运行了两次。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄生组合式继承的核心方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承父类的原型</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Object</span>.create(parent.prototype);</span><br><span class="line">  <span class="comment">// 重写子类的原型</span></span><br><span class="line">  child.prototype = p;</span><br><span class="line">  <span class="comment">// 重写被污染的子类的constructor</span></span><br><span class="line">  <span class="comment">// 这里我也看不太懂。看浏览器结果的意思是使用子类作为父类的构造函数</span></span><br><span class="line">  p.constructor = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mistCombinSon</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  FatherFun.call(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.c = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">inherit(mistCombinSon, FatherFun);</span><br><span class="line"><span class="keyword">let</span> mistCombinSon1 = <span class="keyword">new</span> mistCombinSon();</span><br><span class="line"><span class="built_in">console</span>.log(mistCombinSon1.a);</span><br><span class="line">mistCombinSon1.methodA();</span><br><span class="line"><span class="comment">// mistCombinSon &#123;a: &quot;a&quot;, b: &quot;b&quot;, c: &quot;c&quot;&#125;</span></span><br><span class="line"><span class="comment">//     a: &quot;a&quot;</span></span><br><span class="line"><span class="comment">//     b: &quot;b&quot;</span></span><br><span class="line"><span class="comment">//     c: &quot;c&quot;</span></span><br><span class="line"><span class="comment">//     __proto__: FatherFun</span></span><br><span class="line"><span class="comment">//         constructor: ƒ mistCombinSon()</span></span><br><span class="line"><span class="comment">//         __proto__: Object</span></span><br><span class="line"><span class="comment">//             methodA: ƒ ()</span></span><br><span class="line"><span class="comment">//             constructor: ƒ FatherFun(a = &#x27;a&#x27;, b = &#x27;b&#x27;)</span></span><br><span class="line"><span class="comment">//             __proto__: Object</span></span><br><span class="line"><span class="comment">// 父类原型上没有属性和方法，构造器被设置成了子类的构造函数。父类的方法被放到了父类的对象原型中，</span></span><br><span class="line"><span class="comment">// 子类继承了父类的属性和方法，同时，属性没有被创建在原型链上，因此多个子类不会共享同一个属性。</span></span><br><span class="line"><span class="comment">// 子类可以传递动态参数给父类！</span></span><br><span class="line"><span class="comment">// 父类的构造函数只执行了一次！</span></span><br><span class="line"><span class="comment">// * 原PO说 子类想要在原型上添加方法，必须在继承之后添加，否则将覆盖掉原有原型上的方法。这样的话 若是已经存在的两个类，就不好办了。</span></span><br><span class="line"><span class="comment">// 这里的大概意思说的就是如果需要向子类原型上添加方法，需要挨个给子类添加，不能直接向父类添加。</span></span><br></pre></td></tr></table></figure>
<h4 id="ES6-的继承"><a href="#ES6-的继承" class="headerlink" title="ES6 的继承"></a>ES6 的继承</h4><p>参考 <a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class-extends">https://es6.ruanyifeng.com/#docs/class-extends</a></p>
<p>首先最关键的是关键字 <code>extends</code> ，通过这个关键字表示子类继承父类。</p>
<p>使用 <code>extends</code> 在构造器中需要配套使用 <code>super</code> 方法运行父类的构造器，再运行子类后面的构造代码。</p>
<p><code>super</code> 虽然代表了父类 <code>A</code> 的构造函数，但是返回的是子类 <code>B</code> 的实例，即 <code>super</code> 内部的 <code>this</code> 指的是 <code>B</code> 的实例，因此 <code>super()</code> 在这里相当于 <code>A.prototype.constructor.call(this)</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">extendsSon</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">a = <span class="string">&quot;a&quot;</span>, b = <span class="string">&quot;b&quot;</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(a, b);</span><br><span class="line">    <span class="built_in">this</span>.c = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> extendsSon1 = <span class="keyword">new</span> extendsSon();</span><br><span class="line"><span class="built_in">console</span>.log(extendsSon1.a);</span><br><span class="line">extendsSon1.methodA();</span><br><span class="line"><span class="comment">// extendsSon &#123;a: &quot;a&quot;, b: &quot;b&quot;, c: &quot;c&quot;&#125;</span></span><br><span class="line"><span class="comment">//     a: &quot;a&quot;</span></span><br><span class="line"><span class="comment">//     b: &quot;b&quot;</span></span><br><span class="line"><span class="comment">//     c: &quot;c&quot;</span></span><br><span class="line"><span class="comment">//     __proto__: Father</span></span><br><span class="line"><span class="comment">//         constructor: class extendsSon</span></span><br><span class="line"><span class="comment">//         __proto__:</span></span><br><span class="line"><span class="comment">//             constructor: class Father</span></span><br><span class="line"><span class="comment">//             methodA: ƒ methodA()</span></span><br><span class="line"><span class="comment">//             __proto__: Object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 感觉ES6的继承很完美嘛，父类构造函数只运行一次，属性也都是被子类继承，但是父类原型方法由原型链查询。修改也很方便。</span></span><br></pre></td></tr></table></figure>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是通过设定私有变量和方法，让外部通过接口去调用方法。防止直接修改内部数据和方法。</p>
<p>闭包可以实现私有方法，通过返回含有多个接口的方法，来隐藏真正的方法。</p>
<p>私有变量也可以通过闭包的词法环境实现，在闭包的词法环境中，变量是会得以保存的，但是只有通过 <code>this</code> 绑定在原型属性上的变量会被外部通过原型属性访问，但是通过 <code>var</code> 、 <code>let</code> 、 <code>const</code> 方法定义的变量是不能被外界访问到的，也就实现了私有属性。</p>
<p>ES6 中类（class）通过 <strong>static</strong> 关键字定义静态方法。不能在类的实例上调用静态方法，而应该通过类本身调用。这些通常是实用程序方法，例如创建或克隆对象的功能。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是指在一个接口中对同一个行为，具有不同的表现形式。最常用的实现方法就是通过对父类传入不同的参数，使得多个子类的实例在访问父类的方法时呈现不同的结果。或者说在接口中通过对当前实例的区分来完成不同的行为。</p>
<h2 id="JavaScript-ES6-更新了什么？"><a href="#JavaScript-ES6-更新了什么？" class="headerlink" title="JavaScript ES6 更新了什么？"></a>JavaScript ES6 更新了什么？</h2><p>详细的教程或者文档可以参考 <a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/">阮一峰的教程</a> 和 <a target="_blank" rel="noopener" href="https://www.babeljs.cn/docs/learn.html">Babel 的文档</a></p>
<p>在前端方面有相当多的规范，比如我们所使用的 HTML、CSS、JavaScript 都是有规范的，其中 HTML、CSS 的标准是由 <a target="_blank" rel="noopener" href="https://www.w3.org/standards/">W3C</a> 设定的，还有 XML、XHTML 也是 W3C 制定的标准。JavaScript 的标准则是由 <a target="_blank" rel="noopener" href="https://www.ecma-international.org/publications/standards/Standard.htm">ECMAScript</a> 所制定的，目前最新的规范是 ECMA-262 Edition 6，也被称为 ECMAScript 2015。这是一个大版本的更新，对比第五代的 ECMAScript 更新了很多东西。可以帮助开发者更加方便快捷的开发网页。</p>
<blockquote>
<p>Babel 是一个 JavaScript 编译器。</p>
</blockquote>
<p>Babel 作为 JavaScript 的编译器可以将 ES6 的代码转换成向后兼容的代码，防止出现浏览器兼容错误。</p>
<p>然后就是 JavaScript 的引擎，简单说就是浏览器的核心，目前使用较多的就是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Projects/SpiderMonkey">Firefox 的 SpiderMonkey</a> 和 <a target="_blank" rel="noopener" href="https://v8.dev/">Chrome 的 V8</a> 了，关于 JavaScript 引擎了解的不需要太多。还是关注 JavaScript 的语法标准和原理比较好。</p>
<h3 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h3><p>ES6 中新增了 <code>let</code> 和 <code>const</code> 两个命令，用来声明变量，取代 <code>var</code> ，不同的是 <code>let</code> 和 <code>const</code> 都不会产生变量提升，也就是说他们所声明的变量只能在命令所在的代码块有效。</p>
<p><strong>暂时性死区</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&quot;abc&quot;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>var</code> 声明的 <code>tmp</code> 变量可以看做是一个全局变量，但是由于在 <code>if</code> 循环语句内又声明了一个 <code>tmp</code> ，即使 <code>tmp</code> 在 <code>let</code> 声明之前赋值也是会直接报错的，如果在 <code>let</code> 声明之后赋值的话既是对 <code>let</code> 声明的 <code>tmp</code> 赋值。</p>
<blockquote>
<p>ES6 明确规定，如果区块中存在 <code>let</code> 和 <code>const</code> 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">&quot;abc&quot;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于暂时性死区的特性，在变量声明之前都是属于变量的死区，不管做什么操作都会报错。包括 <code>typeof</code> 。</p>
<p><code>let</code> 也不支持重复声明，相比于 <code>var</code> 来说更加的严格。</p>
<h4 id="新的作用域"><a href="#新的作用域" class="headerlink" title="新的作用域"></a>新的作用域</h4><p>详见 <a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/let#ES6-%E7%9A%84%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">ES6-的块级作用域</a></p>
<p>作用域是用来确定变量的有效范围和调用顺序，在 ES5 中只有全局作用域和函数作用域，在 ES6 中通过 <code>let</code> 新增了块级作用域，尽可能的避免变量提升。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>在没有块级作用域的时候，上面代码的原意是， <code>if</code> 代码块的外部使用外层的 <code>tmp</code> 变量，内部使用内层的 <code>tmp</code> 变量。但是，函数 <code>f</code> 执行后，输出结果为 <code>undefined</code> ，原因在于变量提升，导致内层的 <code>tmp</code> 变量覆盖了外层的 <code>tmp</code> 变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>还有就是在使用 <code>for</code> 循环的时候使用 <code>var</code> 声明的变量会泄露成为全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用了 <code>let</code> 之后会产生块级作用域，使得变量仅在该区域内生效，</p>
<p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两种函数声明，根据 ES5 的规定都是非法的。</p>
<p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p>
<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于 <code>let</code> ，在块级作用域之外不可引用。</p>
<h4 id="函数表达式和函数声明"><a href="#函数表达式和函数声明" class="headerlink" title="函数表达式和函数声明"></a>函数表达式和函数声明</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 块级作用域内部的函数声明语句，建议不要使用</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域内部，优先使用函数表达式</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是由于浏览器为了兼容以前的代码，是会支持的，ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于 <code>let</code> ，在块级作用域之外不可引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;I am outside!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;I am inside!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>在 ES5 中，这个函数声明会被提升到块级作用域头部，并不会受 <code>if</code> 影响，但是在 ES6 中，会因为浏览器的行为而报错。</p>
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于 <code>var</code> ，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;I am outside!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;I am inside!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>
<p>所以在块级作用域内声明函数，最好是使用函数表达式而非函数声明。</p>
<h3 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h3><p><code>const</code> 声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line">PI; <span class="comment">// 3.1415</span></span><br><span class="line"></span><br><span class="line">PI = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>
<p><code>const</code> 命令需要在声明变量同时对变量进行初始化。只声明而不赋值的话也是会报错的。</p>
<p><code>const</code> 和 <code>let</code> 一样，只会在声明的块级作用域内有效，存在暂时性死区，不会被变量提升。</p>
<blockquote>
<p><code>const</code> 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针， <code>const</code> 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br><span class="line">foo.prop; <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: &quot;foo&quot; is read-only</span></span><br></pre></td></tr></table></figure>
<p>如果需要一个彻底不能被修改的变量，不论是对象还是其他类型，可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze"> <code>Object.freeze()</code> </a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">      constantize(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过循环遍历对象的属性可以保证对象内的属性也得到冻结。</p>
<h4 id="顶层对象和全局对象"><a href="#顶层对象和全局对象" class="headerlink" title="顶层对象和全局对象"></a>顶层对象和全局对象</h4><p><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/let#%E9%A1%B6%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7">顶层对象和全局对象</a> 详情就不写了，主要是为了解决前面对于两个对象的区分不严格的问题，达到浏览器和 Node 环境中的统一，</p>
<h3 id="变量解构赋值"><a href="#变量解构赋值" class="headerlink" title="变量解构赋值"></a>变量解构赋值</h3><blockquote>
<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
</blockquote>
<p>以前，为变量赋值，只能直接指定值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>ES6 允许写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>解构赋值的前提是他们的类型需要相同，所以在右边会使用 <code>[]</code> 来包裹值，如果等号左边比右边的值多的话，多的值会被赋值 <code>undefined</code> ，如果右边比左边多的话，多的值会被丢弃不用。</p>
<p>解构赋值允许指定默认值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&quot;b&quot;</span>] = [<span class="string">&quot;a&quot;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&quot;b&quot;</span>] = [<span class="string">&quot;a&quot;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>ES6 内部使用严格相等运算符（ <code>===</code> ），判断一个位置是否有值。所以，只有当一个数组成员严格等于 <code>undefined</code> ，默认值才会生效。</p>
</blockquote>
<p>然后就是对对象的解构赋值，也是同理的。只是写法上不太一样，需要指定目标对象属性值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123;</span><br><span class="line">  foo: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">  bar: <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">foo; <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar; <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123;</span><br><span class="line">  foo: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">  bar: <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">baz; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>同样也是可以给对象指定默认值。</p>
<h3 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h3><p>ES6 加强了对 Unicode 的支持，允许采用 <code>\uxxxx</code> 形式表示一个字符，其中 <code>xxxx</code> 表示字符的 Unicode 码点。</p>
<p>但是，这种表示法只限于码点在 <code>\u0000</code> ~ <code>\uFFFF</code> 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\uD842\uDFB7&quot;</span>;</span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\u20BB7&quot;</span>;</span><br><span class="line"><span class="comment">// &quot; 7&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\u&#123;20BB7&#125;&quot;</span></span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&quot;</span></span><br><span class="line"><span class="comment">// &quot;ABC&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = <span class="number">123</span>;</span><br><span class="line">hell\ u &#123;</span><br><span class="line">    <span class="number">6</span> F</span><br><span class="line">&#125; <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;\u&#123;1F680&#125;&#x27;</span> === <span class="string">&#x27;\uD83D\uDE80&#x27;</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;z&quot;</span> === <span class="string">&quot;z&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;\172&quot;</span> === <span class="string">&quot;z&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;\x7A&quot;</span> === <span class="string">&quot;z&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;\u007A&quot;</span> === <span class="string">&quot;z&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;\u&#123;7A&#125;&quot;</span> === <span class="string">&quot;z&quot;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被 <code>for...of</code> 循环遍历。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">&quot;foo&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(codePoint);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;f&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后是关于模板字符串的改进，让字符串中的变量可以更加方便的输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#result&quot;</span>).append(</span><br><span class="line">  <span class="string">&quot;There are &lt;b&gt;&quot;</span> +</span><br><span class="line">    basket.count +</span><br><span class="line">    <span class="string">&quot;&lt;/b&gt; &quot;</span> +</span><br><span class="line">    <span class="string">&quot;items in your basket, &quot;</span> +</span><br><span class="line">    <span class="string">&quot;&lt;em&gt;&quot;</span> +</span><br><span class="line">    basket.onSale +</span><br><span class="line">    <span class="string">&quot;&lt;/em&gt; are on sale!&quot;</span></span><br><span class="line">);</span><br><span class="line">$(<span class="string">&quot;#result&quot;</span>).append(<span class="string">`</span></span><br><span class="line"><span class="string">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span></span><br><span class="line"><span class="string">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">  are on sale!</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure>
<p>模板字符串（template string）是增强版的字符串，用反引号（\ <code>）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入 </code> ${}` 变量。</p>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p>
<p>ES6 还为原生的 String 对象，提供了一个 <code>raw()</code> 方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span> + <span class="number">3</span>&#125;</span>!`</span>;</span><br><span class="line"><span class="comment">// 实际返回 &quot;Hi\\n5!&quot;，显示的是转义后的结果 &quot;Hi\n5!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</span><br><span class="line"><span class="comment">// 实际返回 &quot;Hi\\u000A!&quot;，显示的是转义后的结果 &quot;Hi\u000A!&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>String.raw()</code> 本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有 <code>raw</code> 属性的对象，且 <code>raw</code> 属性的值应该是一个数组，对应模板字符串解析后的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `foo$&#123;1 + 2&#125;bar`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">String</span>.raw(</span><br><span class="line">  &#123;</span><br><span class="line">    raw: [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">1</span> + <span class="number">2</span></span><br><span class="line">); <span class="comment">// &quot;foo3bar&quot;</span></span><br></pre></td></tr></table></figure>
<p>传统上，JavaScript 只有 <code>indexOf</code> 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p>
<ul>
<li>**includes()**：返回布尔值，表示是否找到了参数字符串。</li>
<li>**startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li>**endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
</ul>
<p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">&quot;world&quot;</span>, <span class="number">6</span>); <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&quot;Hello&quot;</span>, <span class="number">6</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>repeat</code> 方法返回一个新字符串，表示将原字符串重复 <code>n</code> 次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;x&quot;</span>.repeat(<span class="number">3</span>); <span class="comment">// &quot;xxx&quot;</span></span><br><span class="line"><span class="string">&quot;hello&quot;</span>.repeat(<span class="number">2</span>); <span class="comment">// &quot;hellohello&quot;</span></span><br><span class="line"><span class="string">&quot;na&quot;</span>.repeat(<span class="number">0</span>); <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>参数如果是小数，会被取整。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;na&quot;</span>.repeat(<span class="number">2.9</span>); <span class="comment">// &quot;nana&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>repeat</code> 的参数是负数或者 <code>Infinity</code> ，会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;na&quot;</span>.repeat(<span class="literal">Infinity</span>);</span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="string">&quot;na&quot;</span>.repeat(-<span class="number">1</span>);</span><br><span class="line"><span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure>
<p>但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于 <code>-0</code> ， <code>repeat</code> 视同为 0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;na&quot;</span>.repeat(-<span class="number">0.9</span>); <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>参数 <code>NaN</code> 等同于 0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;na&quot;</span>.repeat(<span class="literal">NaN</span>); <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>repeat</code> 的参数是字符串，则会先转换成数字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;na&quot;</span>.repeat(<span class="string">&quot;na&quot;</span>); <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="string">&quot;na&quot;</span>.repeat(<span class="string">&quot;3&quot;</span>); <span class="comment">// &quot;nanana&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="正则表达式的改进"><a href="#正则表达式的改进" class="headerlink" title="正则表达式的改进"></a>正则表达式的改进</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp"> <code>RegExp</code> </a>构造函数创建了一个正则表达式对象，用于将文本与一个模式匹配。</p>
</blockquote>
<p>在 ES5 中的 <code>RegExp</code> 构造函数中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;xyz&#x27;</span>, <span class="string">&#x27;i&#x27;</span>)</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/i</span>)</span><br></pre></td></tr></table></figure>
<p><code>RegExp</code> 可以接受两个字符串作为参数，或者是一个完整的正则语句作为参数。</p>
<p>但是不能</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RegExp</span>(<span class="regexp">/xyz/</span>, <span class="string">&quot;i&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>不过在 ES6 中可以这样使用，如果前面的正则中有已经设定的修饰符，会被后面的第二个参数所覆盖。</p>
<p>感觉都不推荐使用，因为表达的意义太模糊了。还是直接使用完整的正则表达式比较好，意义明确，格式也不会因为字符串的原因而被取消高亮。而且覆盖修饰符感觉没有什么意义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/i</span>); <span class="comment">// 意义更加清楚而且美观。</span></span><br></pre></td></tr></table></figure>
<p>以前的字符串内置四种正则表达式方法， <code>match()</code> 、 <code>replace()</code> 、 <code>search()</code> 、 <code>split()</code> ，用于对字符串进行匹配、替换、查询、切割操作。</p>
<p>ES6 将这四种方法从新定义在 <code>RegExp</code> 对象上，字符串还是可以使用，间接调用而已。</p>
<h4 id="u-修饰符"><a href="#u-修饰符" class="headerlink" title="u 修饰符"></a>u 修饰符</h4><p>ES6 新增了 <code>u</code> 修饰符，用来正确处理 Unicode 字符。ES5 不支持四个字节的 UTF-16 编码，将其识别为两个字符。</p>
<p><code>u</code> 修饰符对于大于 <code>0xFFFF</code> 的字符都有效果，所以在使用中文正则时是常用的。</p>
<p>ES6 新增了使用大括号表示 Unicode 字符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/\u&#123;<span class="number">61</span>&#125;/.test(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">    /</span><br><span class="line">    \u &#123;</span><br><span class="line">        <span class="number">61</span></span><br><span class="line">    &#125;</span><br><span class="line">/u.test(<span class="string">&#x27;a&#x27;</span>) / / <span class="literal">true</span></span><br><span class="line">    /</span><br><span class="line">    \u &#123;</span><br><span class="line">        <span class="number">20</span> BB7</span><br><span class="line">    &#125;</span><br><span class="line">/u.test(<span class="string">&#x27;𠮷&#x27;</span>) / / <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>使用大括号表示 Unicode 字符必须使用 <code>u</code> 修饰符。</p>
<p>包括量词、占位符、预定义模式等大于 <code>0xFFFF</code> 的 Unicode 字符都需要使用 <code>u</code> 修饰符才能正确匹配。</p>
<p>设置了 <code>u</code> 修饰符后会在生成 <code>RegExp</code> 对象时设置新增的 <code>unicode</code> 属性为 true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> r1 = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">const</span> r2 = <span class="regexp">/hello/u</span>;</span><br><span class="line"></span><br><span class="line">r1.unicode; <span class="comment">// false</span></span><br><span class="line">r2.unicode; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="y-修饰符"><a href="#y-修饰符" class="headerlink" title="y 修饰符"></a>y 修饰符</h4><p>ES6 新增 <code>y</code> 修饰符，叫做“粘连”（sticky）修饰符。</p>
<blockquote>
<p><code>y</code> 修饰符的作用与 <code>g</code> 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于， <code>g</code> 修饰符只要剩余位置中存在匹配就可，而 <code>y</code> 修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;aaa_aa_a&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</span><br><span class="line"></span><br><span class="line">r1.exec(s); <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line">r2.exec(s); <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line"></span><br><span class="line">r1.exec(s); <span class="comment">// [&quot;aa&quot;]</span></span><br><span class="line">r2.exec(s); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>上面代码有两个正则表达式，一个使用 <code>g</code> 修饰符，另一个使用 <code>y</code> 修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是 <code>_aa_a</code> 。由于 <code>g</code> 修饰没有位置要求，所以第二次执行会返回结果，而 <code>y</code> 修饰符要求匹配必须从头部开始， <code>_aa_a</code> 第一个字符不匹配，所以返回 <code>null</code> 。</p>
<p><code>y</code> 修饰符的设计本意，就是让头部匹配的标志 <code>^</code> 在全局匹配中都有效。</p>
<p>在某些场景下对比 <code>g</code> 修饰符来说更加严格，更容易发现错误。</p>
<p>同样 <code>RegExp</code> 也添加了 <code>sticky</code> 属性用来表示是否设置了 <code>y</code> 修饰符。</p>
<p>还有 <code>source</code> 和 <code>flags</code> 属性用来表示正则表达式的正文和修饰符。</p>
<h4 id="s-修饰符"><a href="#s-修饰符" class="headerlink" title="s 修饰符"></a>s 修饰符</h4><p>正则表达式中，点（ <code>.</code> ）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用 <code>u</code> 修饰符解决；另一个是行终止符（line terminator character）。</p>
<p>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。</p>
<ul>
<li>U+000A 换行符（ <code>\n</code> ）</li>
<li>U+000D 回车符（ <code>\r</code> ）</li>
<li>U+2028 行分隔符（line separator）</li>
<li>U+2029 段分隔符（paragraph separator）</li>
</ul>
<p>ES2018 <a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-regexp-dotall-flag">引入</a> <code>s</code> 修饰符，使得 <code>.</code> 可以匹配任意单个字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/foo.bar/s.test(<span class="string">&quot;foo\nbar&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这被称为 <code>dotAll</code> 模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个 <code>dotAll</code> 属性，返回一个布尔值，表示该正则表达式是否处在 <code>dotAll</code> 模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/foo.bar/</span>s;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="comment">// const re = new RegExp(&#x27;foo.bar&#x27;, &#x27;s&#x27;);</span></span><br><span class="line"></span><br><span class="line">re.test(<span class="string">&quot;foo\nbar&quot;</span>); <span class="comment">// true</span></span><br><span class="line">re.dotAll; <span class="comment">// true</span></span><br><span class="line">re.flags; <span class="comment">// &#x27;s&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>/s</code> 修饰符和多行修饰符 <code>/m</code> 不冲突，两者一起使用的情况下， <code>.</code> 匹配所有字符，而 <code>^</code> 和 <code>$</code> 匹配每一行的行首和行尾。</p>
<h4 id="后行断言"><a href="#后行断言" class="headerlink" title="后行断言"></a>后行断言</h4><p>“先行断言”指的是， <code>x</code> 只有在 <code>y</code> 前面才匹配，必须写成 <code>/x(?=y)/</code> 。比如，只匹配百分号之前的数字，要写成 <code>/\d+(?=%)/</code> 。“先行否定断言”指的是， <code>x</code> 只有不在 <code>y</code> 前面才匹配，必须写成 <code>/x(?!y)/</code> 。比如，只匹配不在百分号之前的数字，要写成 <code>/\d+(?!%)/</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/\d+(?=%)/.exec(<span class="string">&#x27;100% of US presidents have been male&#x27;</span>) <span class="comment">// [&quot;100&quot;]</span></span><br><span class="line">    /</span><br><span class="line">    \d + ( ? ! % ) / .exec(<span class="string">&#x27;that’s all 44 of them&#x27;</span>) <span class="comment">// [&quot;44&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（ <code>(?=%)</code> ），是不计入返回结果的。</p>
<p>“后行断言”正好与“先行断言”相反， <code>x</code> 只有在 <code>y</code> 后面才匹配，必须写成 <code>/(?&lt;=y)x/</code> 。比如，只匹配美元符号之后的数字，要写成 <code>/(?&lt;=\$)\d+/</code> 。“后行否定断言”则与“先行否定断言”相反， <code>x</code> 只有不在 <code>y</code> 后面才匹配，必须写成 <code>/(?。比如，只匹配不在美元符号后面的数字，要写成</code> /(?。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=\$)\d+<span class="regexp">/.exec(&#x27;Benjamin Franklin is on the $100 bill&#x27;) /</span><span class="regexp">/ [&quot;100&quot;]</span></span><br><span class="line"><span class="regexp">    /</span></span><br><span class="line">    ( ? &lt; !\$)\ d + <span class="regexp">/.exec(&#x27;it’s is worth about €90&#x27;)                /</span> / [<span class="string">&quot;90&quot;</span>]</span><br></pre></td></tr></table></figure>
<h4 id="具名组匹配"><a href="#具名组匹配" class="headerlink" title="具名组匹配"></a>具名组匹配</h4><p>在正则表达式中，通常使用圆括号进行组匹配，并返回匹配到的内容</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">&quot;1999-12-31&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<p>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如 <code>matchObj[1]</code> ）引用，要是组的顺序变了，引用的时候就必须修改序号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">&quot;1999-12-31&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.groups.year; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.groups.month; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.groups.day; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（ <code>?</code> ），然后就可以在 <code>exec</code> 方法返回结果的 <code>groups</code> 属性上引用该组名。同时，数字序号（ <code>matchObj[1]</code> ）依然有效。</p>
<p>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。</p>
<p>有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  groups: &#123; one, two &#125;,</span><br><span class="line">&#125; = <span class="regexp">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.exec(<span class="string">&quot;foo:bar&quot;</span>);</span><br><span class="line">one; <span class="comment">// foo</span></span><br><span class="line">two; <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<p>字符串替换时，使用 <code>$&lt;组名&gt;</code> 引用具名组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;2015-01-02&quot;</span>.replace(re, <span class="string">&quot;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;02/01/2015&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中， <code>replace</code> 方法的第二个参数是一个字符串，而不是正则表达式。</p>
<p><code>replace</code> 方法的第二个参数也可以是函数，该函数的参数序列如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;2015-01-02&quot;</span>.replace(</span><br><span class="line">  re,</span><br><span class="line">  (</span><br><span class="line">    matched, <span class="comment">// 整个匹配结果 2015-01-02</span></span><br><span class="line">    capture1, <span class="comment">// 第一个组匹配 2015</span></span><br><span class="line">    capture2, <span class="comment">// 第二个组匹配 01</span></span><br><span class="line">    capture3, <span class="comment">// 第三个组匹配 02</span></span><br><span class="line">    position, <span class="comment">// 匹配开始的位置 0</span></span><br><span class="line">    S, <span class="comment">// 原字符串 2015-01-02</span></span><br><span class="line">    groups <span class="comment">// 具名组构成的一个对象 &#123;year, month, day&#125;</span></span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; day, month, year &#125; = groups;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;day&#125;</span>/<span class="subst">$&#123;month&#125;</span>/<span class="subst">$&#123;year&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。</p>
<p>如果要在正则表达式内部引用某个“具名组匹配”，可以使用 <code>\k&lt;组名&gt;</code> 的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">&quot;abc!abc&quot;</span>); <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">&quot;abc!ab&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>数字引用（ <code>\1</code> ）依然有效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\1$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">&quot;abc!abc&quot;</span>); <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">&quot;abc!ab&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="正则匹配索引"><a href="#正则匹配索引" class="headerlink" title="正则匹配索引"></a>正则匹配索引</h4><p>正则表达式返回的结果中一般会包含 <code>index</code> 属性，表示匹配到的字符串的开始位置，但是如果是组匹配的话， <code>index</code> 会是第一个匹配结果的开始位置。</p>
<p>现在有一个<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-regexp-match-Indices">第三阶段提案</a>，为 <code>exec()</code> 方法的返回结果加上 <code>indices</code> 属性，在这个属性上面可以拿到匹配的开始位置和结束位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&quot;zabbcdef&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.exec(text);</span><br><span class="line"></span><br><span class="line">result.index; <span class="comment">// 1</span></span><br><span class="line">result.indices; <span class="comment">// [ [1, 3] ]</span></span><br></pre></td></tr></table></figure>
<p>上面例子中， <code>exec()</code> 方法的返回结果 <code>result</code> ，它的 <code>index</code> 属性是整个匹配结果（ <code>ab</code> ）的开始位置，而它的 <code>indices</code> 属性是一个数组，成员是每个匹配的开始位置和结束位置的数组。由于该例子的正则表达式没有组匹配，所以 <code>indices</code> 数组只有一个成员，表示整个匹配的开始位置是 <code>1</code> ，结束位置是 <code>3</code> 。</p>
<p>注意，开始位置包含在匹配结果之中，但是结束位置不包含在匹配结果之中。比如，匹配结果为 <code>ab</code> ，分别是原始字符串的第 1 位和第 2 位，那么结束位置就是第 3 位。</p>
<p>如果正则表达式包含组匹配，那么 <code>indices</code> 属性对应的数组就会包含多个成员，提供每个组匹配的开始位置和结束位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&quot;zabbcdef&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab+(cd)/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.exec(text);</span><br><span class="line"></span><br><span class="line">result.indices; <span class="comment">// [ [ 1, 6 ], [ 4, 6 ] ]</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，正则表达式包含一个组匹配，那么 <code>indices</code> 属性数组就有两个成员，第一个成员是整个匹配结果（ <code>abbcd</code> ）的开始位置和结束位置，第二个成员是组匹配（ <code>cd</code> ）的开始位置和结束位置。</p>
<p>如果正则表达式包含具名组匹配， <code>indices</code> 属性数组还会有一个 <code>groups</code> 属性。该属性是一个对象，可以从该对象获取具名组匹配的开始位置和结束位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&quot;zabbcdef&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab+(?&lt;Z&gt;cd)/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.exec(text);</span><br><span class="line"></span><br><span class="line">result.indices.groups; <span class="comment">// &#123; Z: [ 4, 6 ] &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String. prototype. matchAll()"></a>String. prototype. matchAll()</h4><p>这是字符串的一个方法，用于返回所有匹配，不过他返回的是一个遍历器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">&quot;test1test2test3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g 修饰符加不加都可以</span></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> string.matchAll(regex)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于 <code>string.matchAll(regex)</code> 返回的是遍历器，所以可以用 <code>for...of</code> 循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。</p>
<h3 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h3><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀 <code>0b</code> （或 <code>0B</code> ）和 <code>0o</code> （或 <code>0O</code> ）表示。</p>
<p>ES6 在 <code>Number</code> 对象上，新提供了 <code>Number.isFinite()</code> 和 <code>Number.isNaN()</code> 两个方法。</p>
<p><code>Number.isFinite()</code> 用来检查一个数值是否为有限的（finite），即不是 <code>Infinity</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">15</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0.8</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(-<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&quot;foo&quot;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&quot;15&quot;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>Number.isNaN()</code> 用来检查一个值是否为 <code>NaN</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">15</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&quot;15&quot;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">9</span> / <span class="literal">NaN</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&quot;true&quot;</span> / <span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&quot;true&quot;</span> / <span class="string">&quot;true&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这两个方法对于非数值一律返回 <code>false</code> 。在调用时需要使用 Number 类，不然会使用以前的传统方法。</p>
<p>ES6 将全局方法 <code>parseInt()</code> 和 <code>parseFloat()</code> ，移植到 <code>Number</code> 对象上面，行为完全保持不变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;12.34&quot;</span>); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;123.45#&quot;</span>); <span class="comment">// 123.45</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">&quot;12.34&quot;</span>); <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(<span class="string">&quot;123.45#&quot;</span>); <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure>
<p><code>Number.isInteger()</code> 用来判断一个数值是否为整数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.1</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25. 0 被视为同一个值。</p>
<p>注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为 64 位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第 54 位及后面的位就会被丢弃，这种情况下， <code>Number.isInteger</code> 可能会误判。</p>
<p>类似的情况还有，如果一个数值的绝对值小于 <code>Number.MIN_VALUE</code> （5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时， <code>Number.isInteger</code> 也会误判。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">5e-324</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">5e-325</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中， <code>5E-325</code> 由于值太小，会被自动转为 0，因此返回 <code>true</code> 。</p>
<p>JavaScript 能够准确表示的整数范围在 <code>-2^53</code> 到 <code>2^53</code> 之间（不含两个端点），超过这个范围，无法精确表示这个值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>); <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="number">9007199254740992</span>; <span class="comment">// 9007199254740992</span></span><br><span class="line"><span class="number">9007199254740993</span>; <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，超出 2 的 53 次方之后，一个数就不精确了。</p>
<p>ES6 引入了 <code>Number.MAX_SAFE_INTEGER</code> 和 <code>Number.MIN_SAFE_INTEGER</code> 这两个常量，用来表示这个范围的上下限。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="number">9007199254740991</span>;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="number">9007199254740991</span>;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>Number.isSafeInteger()</code> 则是用来判断一个整数是否落在这个范围之内。但是如果是一个计算式的话很可能返回一个错误的结果。因为在计算的时候就已经超出精度了。</p>
<p>新的 Math 方法</p>
<ul>
<li><p>Math. trunc()</p>
<blockquote>
<p><code>Math.trunc</code> 方法用于去除一个数的小数部分，返回整数部分。</p>
</blockquote>
</li>
<li><p>Math. sign()</p>
<blockquote>
<p><code>Math.sign</code> 方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p>
<p>它会返回五种值。</p>
<ul>
<li>参数为正数，返回 <code>+1</code> ；</li>
<li>参数为负数，返回 <code>-1</code> ；</li>
<li>参数为 0，返回 <code>0</code> ；</li>
<li>参数为-0，返回 <code>-0</code> ;</li>
<li>其他值，返回 <code>NaN</code> 。</li>
</ul>
</blockquote>
</li>
<li><p>Math. cbrt()</p>
<blockquote>
<p><code>Math.cbrt</code> 方法用于计算一个数的立方根。</p>
</blockquote>
</li>
<li><p>Math. clz32()</p>
<blockquote>
<p><code>Math.clz32()</code> 方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。</p>
</blockquote>
</li>
<li><p>Math. imul()</p>
<blockquote>
<p><code>Math.imul</code> 方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p>
</blockquote>
</li>
<li><p>Math. fround()</p>
<blockquote>
<p><code>Math.fround</code> 方法返回一个数的 32 位单精度浮点数形式。</p>
</blockquote>
</li>
<li><p>Math. hypot()</p>
<blockquote>
<p><code>Math.hypot</code> 方法返回所有参数的平方和的平方根。</p>
</blockquote>
</li>
<li><p>Math. expm1()</p>
<blockquote>
<p><code>Math.expm1(x)</code> 返回 ex - 1，即 <code>Math.exp(x) - 1</code> 。</p>
</blockquote>
</li>
<li><p>Math. log1p()</p>
<blockquote>
<p><code>Math.log1p(x)</code> 方法返回 <code>1 + x</code> 的自然对数，即 <code>Math.log(1 + x)</code> 。如果 <code>x</code> 小于-1，返回 <code>NaN</code> 。</p>
</blockquote>
</li>
<li><p>Math. log10()</p>
<blockquote>
<p><code>Math.log10(x)</code> 返回以 10 为底的 <code>x</code> 的对数。如果 <code>x</code> 小于 0，则返回 NaN。</p>
</blockquote>
</li>
<li><p>Math. log2()</p>
<blockquote>
<p><code>Math.log2(x)</code> 返回以 2 为底的 <code>x</code> 的对数。如果 <code>x</code> 小于 0，则返回 NaN。</p>
</blockquote>
</li>
</ul>
<p>ES6 新增了 6 个双曲函数方法。</p>
<ul>
<li><code>Math.sinh(x)</code> 返回 <code>x</code> 的双曲正弦（hyperbolic sine）</li>
<li><code>Math.cosh(x)</code> 返回 <code>x</code> 的双曲余弦（hyperbolic cosine）</li>
<li><code>Math.tanh(x)</code> 返回 <code>x</code> 的双曲正切（hyperbolic tangent）</li>
<li><code>Math.asinh(x)</code> 返回 <code>x</code> 的反双曲正弦（inverse hyperbolic sine）</li>
<li><code>Math.acosh(x)</code> 返回 <code>x</code> 的反双曲余弦（inverse hyperbolic cosine）</li>
<li><code>Math.atanh(x)</code> 返回 <code>x</code> 的反双曲正切（inverse hyperbolic tangent）</li>
</ul>
<p>ES2016 新增了一个指数运算符（ <code>**</code> ）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span>; <span class="comment">// 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span>; <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。</p>
<h4 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h4><p>JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于 2 的 1024 次方的数值，JavaScript 无法表示，会返回 <code>Infinity</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超过 53 个二进制位的数值，无法保持精度</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超过 2 的 1024 次方的数值，无法表示</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>); <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-bigint">ES2020</a> 引入了一种新的数据类型 BigInt（大整数），来解决这个问题。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">2172141653n</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">15346349309n</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 可以保持精度</span></span><br><span class="line">a * b; <span class="comment">// 33334444555566667777n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通整数无法保持精度</span></span><br><span class="line"><span class="built_in">Number</span>(a) * <span class="built_in">Number</span>(b); <span class="comment">// 33334444555566670000</span></span><br></pre></td></tr></table></figure>
<p>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀 <code>n</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1234</span>; <span class="comment">// 普通整数</span></span><br><span class="line"><span class="number">1234n</span>; <span class="comment">// BigInt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 的运算</span></span><br><span class="line"><span class="number">1n</span> + <span class="number">2n</span>; <span class="comment">// 3n</span></span><br></pre></td></tr></table></figure>
<p>BigInt 同样可以使用各种进制表示，都要加上后缀 <code>n</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b1101</span> n <span class="comment">// 二进制</span></span><br><span class="line"><span class="number">0o777</span> n <span class="comment">// 八进制</span></span><br><span class="line"><span class="number">0xFF</span> n <span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure>
<p>BigInt 与普通整数是两种值，它们之间并不相等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42n</span> === <span class="number">42</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>typeof</code> 运算符对于 BigInt 类型的数据返回 <code>bigint</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">123n</span>; <span class="comment">// &#x27;bigint&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><h4 id="参数默认值设置"><a href="#参数默认值设置" class="headerlink" title="参数默认值设置"></a>参数默认值设置</h4><p>ES6 之前，不能为函数参数提供默认值，只能通过对参数进行判断是否为空来为它赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  y = y || <span class="string">&quot;World&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;China&quot;</span>); <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;&quot;</span>); <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>
<p>但是如果 y 的赋值布尔值为 false 也是会被修改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> y === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  y = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用类型判断更加合理。</p>
<p>ES6 中允许为函数参数设置默认值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">&quot;World&quot;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;China&quot;</span>); <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;&quot;</span>); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123; x = <span class="number">0</span>, y = <span class="number">0</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  &#123; x, y &#125; = &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    x: <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    y: <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数没有参数的情况</span></span><br><span class="line">m1(); <span class="comment">// [0, 0]</span></span><br><span class="line">m2(); <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都有值的情况</span></span><br><span class="line">m1(&#123;</span><br><span class="line">  x: <span class="number">3</span>,</span><br><span class="line">  y: <span class="number">8</span>,</span><br><span class="line">&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">m2(&#123;</span><br><span class="line">  x: <span class="number">3</span>,</span><br><span class="line">  y: <span class="number">8</span>,</span><br><span class="line">&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 有值，y 无值的情况</span></span><br><span class="line">m1(&#123;</span><br><span class="line">  x: <span class="number">3</span>,</span><br><span class="line">&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">m2(&#123;</span><br><span class="line">  x: <span class="number">3</span>,</span><br><span class="line">&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都无值的情况</span></span><br><span class="line">m1(&#123;&#125;); <span class="comment">// [0, 0];</span></span><br><span class="line">m2(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line"></span><br><span class="line">m1(&#123;</span><br><span class="line">  z: <span class="number">3</span>,</span><br><span class="line">&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">m2(&#123;</span><br><span class="line">  z: <span class="number">3</span>,</span><br><span class="line">&#125;); <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure>
<p>在上面的实例中，写法一设置默认值是空对象，但是对于函数内部调用时的解构是赋予了默认值的，写法二虽然设置了默认值，但是在函数内部，没有设置解构赋值的默认值，相当于只是声明了两个变量，于是在传入无值情况的时候回返回 undefined，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x = <span class="number">1</span>, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// [1, undefined]</span></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// [2, undefined]</span></span><br><span class="line">f(, <span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line">f(<span class="literal">undefined</span>, <span class="number">1</span>) <span class="comment">// [1, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = <span class="number">5</span>, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y, z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// [undefined, 5, undefined]</span></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">// [1, 5, undefined]</span></span><br><span class="line">f(<span class="number">1</span>, , <span class="number">2</span>) <span class="comment">// 报错</span></span><br><span class="line">f(<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">2</span>) <span class="comment">// [1, 5, 2]</span></span><br></pre></td></tr></table></figure>
<p>设置默认值也是与参数的位置有关系的，如果在第一个参数设置默认值，后面的参数不设置，就需要在使用的时候传入 <code>undefined</code> 作为占位。</p>
<p>指定了默认值以后，函数的 <code>length</code> 属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后， <code>length</code> 属性将失真。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;</span><br><span class="line">  .length(</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;</span><br><span class="line">  )</span><br><span class="line">  .length(</span><br><span class="line">    <span class="comment">// 0</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;</span><br><span class="line">  ).length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>在使用了默认值后，函数的声明初始化阶段会形成一个单独的作用域，用于给参数赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，参数 <code>y</code> 的默认值等于变量 <code>x</code> 。调用函数 <code>f</code> 时，参数形成一个单独的作用域。在这个作用域里面，默认值变量 <code>x</code> 指向第一个参数 <code>x</code> ，而不是全局变量 <code>x</code> ，所以输出是 <code>2</code> 。</p>
<p>再看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Missing parameter&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided = throwIfMissing()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// Error: Missing parameter</span></span><br></pre></td></tr></table></figure>
<p>上面代码的 <code>foo</code> 函数，如果调用的时候没有参数，就会调用默认值 <code>throwIfMissing</code> 函数，从而抛出一个错误。</p>
<p>从上面代码还可以看到，参数 <code>mustBeProvided</code> 的默认值等于 <code>throwIfMissing</code> 函数的运行结果（注意函数名 <code>throwIfMissing</code> 之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。</p>
<p>另外，可以将参数默认值设为 <code>undefined</code> ，表明这个参数是可以省略的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">optional = <span class="literal">undefined</span></span>) </span>&#123;</span><br><span class="line">    ···&#125;</span><br></pre></td></tr></table></figure>
<h4 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h4><p>ES6 引入 rest 参数（形式为 <code>...变量名</code> ），用于获取函数的多余参数，这样就不需要使用 <code>arguments</code> 对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>ES6 允许使用“箭头”（ <code>=&gt;</code> ）定义函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">v</span>) =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">() =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>箭头函数可以与变量解构结合使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">&quot; &quot;</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.first + <span class="string">&quot; &quot;</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的 <code>this</code> 对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用 <code>new</code> 命令，否则会抛出一个错误。</p>
<p>（3）不可以使用 <code>arguments</code> 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>（4）不可以使用 <code>yield</code> 命令，因此箭头函数不能用作 Generator 函数。</p>
<p>上面四点中，第一点尤其值得注意。 <code>this</code> 对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
<p><code>this</code> 指向的固定化，并不是因为箭头函数内部有绑定 <code>this</code> 的机制，实际原因是箭头函数根本没有自己的 <code>this</code> ，导致内部的 <code>this</code> 就是外层代码块的 <code>this</code> 。正是因为它没有 <code>this</code> ，所以也就不能用作构造函数。</p>
<p>所以，箭头函数转成 ES5 的代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;id:&quot;</span>, <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;id:&quot;</span>, _this.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="尾调用和尾递归"><a href="#尾调用和尾递归" class="headerlink" title="尾调用和尾递归"></a>尾调用和尾递归</h4><p>尾调用指的是在函数的最后一步调用另一个函数。</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<p>这样的话对于内存的优化是很有帮助的。尾递归同理只是调用的是自己，递归是非常消耗内存的操作，但是如果是尾递归的话就只需要存在一个调用帧，即节省了内存也使得内存更加安全。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>上面代码是一个阶乘函数，计算 <code>n</code> 的阶乘，最多需要保存 <code>n</code> 个调用记录，复杂度 O(n) 。</p>
<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。</p>
<p>非尾递归的 Fibonacci 数列实现如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fibonacci(<span class="number">10</span>); <span class="comment">// 89</span></span><br><span class="line">Fibonacci(<span class="number">100</span>); <span class="comment">// 超时</span></span><br><span class="line">Fibonacci(<span class="number">500</span>); <span class="comment">// 超时</span></span><br></pre></td></tr></table></figure>
<p>尾递归优化过的 Fibonacci 数列实现如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci2</span>(<span class="params">n, ac1 = <span class="number">1</span>, ac2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ac2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Fibonacci2(n - <span class="number">1</span>, ac2, ac1 + ac2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fibonacci2(<span class="number">100</span>); <span class="comment">// 573147844013817200000</span></span><br><span class="line">Fibonacci2(<span class="number">1000</span>); <span class="comment">// 7.0330367711422765e+208</span></span><br><span class="line">Fibonacci2(<span class="number">10000</span>); <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>
<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。</p>
<p>这么看的话尾递归相比较递归函数来说好处实在太多了，那么递归函数都可以改写成尾递归吗？在需要前者计算的递归函数中，比如阶乘，通过一个中间变量 total，取消了调用后的操作，将需要计算的部分交给递归后的函数，使得递归函数在返回后就可以释放空间。</p>
<h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><blockquote>
<p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(<span class="built_in">this</span>, m, n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = currying(tailFactorial, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>上面代码通过柯里化，将尾递归函数 <code>tailFactorial</code> 变为只接受一个参数的 <code>factorial</code> 。</p>
<p><code>currying</code> 返回的是一个函数，并通过 <code>call</code> 方法调用传入的 <code>fn</code> 函数以及设定的 <code>n</code> 参数， <code>m</code> 参数是返回后由 <code>factorial</code> 函数传递，在这里是 5。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> fn.call(<span class="built_in">this</span>, m, n);</span><br></pre></td></tr></table></figure>
<p>回看 <code>call</code> 方法，目的是为了使 <code>currying</code> 继承 <code>tailFactorial</code> 函数，这里的 <code>this</code> 并不是返回的匿名函数，匿名函数没有 <code>this</code> 所以指的是 <code>currying</code> 函数，通过 <code>call</code> 方法调用实际需要使用的 <code>tailFactorial</code> 函数。</p>
<blockquote>
<p><code>call()</code> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call</a></p>
<p>通过 <code>currying</code> 函数返回的匿名函数由 <code>factorial</code> 接收，设定的 <code>tailFactorial</code> 中的 <code>total</code> 为 1，传入 <code>n=5</code> ，返回 120。</p>
<p>上面使用柯里化设置 <code>total</code> 值，完全可以直接使用默认值设置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>还有一个柯里化的经典例题是实现 <code>add(1)(2, 3)(4)() = 10</code> 的效果</p>
<p>不管有几个括号，括号里几个参数，都只需要累加 。</p>
<p>完整代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> allArgs = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            allArgs = allArgs.concat(args);</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, allArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add = currying(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">作者： 我是leon</span><br><span class="line">链接： https: <span class="comment">//juejin.im/post/5b561426518825195f499772</span></span><br><span class="line">    来源： 掘金</span><br><span class="line">著作权归作者所有。 商业转载请联系作者获得授权， 非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>在上面的代码中， <code>currying</code> 函数返回的是 <code>next()</code> 函数， <code>currying</code> 函数接收到的 <code>fn</code> 是后面给 <code>add</code> 赋值时传入的匿名函数，匿名函数的作用是将默认的参数 <code>arguments</code> 使用 for 循环相加返回累加和。 <code>currying</code> 的特性例如延迟计算、记忆参数，这是由 <code>currying</code> 函数中的 <code>allArgs</code> ， <code>next()</code> 函数中通过判断参数个数，如果后面还有参数就将参数存入列表，后面是空括号 <code>()</code> 就调用 <code>add</code> 初始化时的匿名函数计算。</p>
<blockquote>
<p>concat() 方法用于连接两个或多个数组。</p>
</blockquote>
<ul>
<li>传入参数时，代码不执行输出结果，而是先记忆起来</li>
<li>当传入空的参数时，代表可以进行真正的运算</li>
</ul>
<p><strong>比较多次接受的参数总数与函数定义时的入参数量，当接受参数的数量大于或等于被 Currying 函数的传入参数数量时，就返回计算结果，否则返回一个继续接受参数的函数。</strong></p>
<p>而且由于 add 并没有在使用后被销毁，如果多次使用的话是算作一起的</p>
<p><code>add(1)(2, 3)(4)()</code> 第一次运行返回 10，第二次就会返回 20.</p>
<h4 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="尾递归优化的实现"></a>尾递归优化的实现</h4><p>再次回到尾递归上来，尾递归优化具体来说是浏览器实现，可能不同的浏览器会有不同的结果。我目前使用的 Chrome 内核的浏览器是可以支持尾递归优化的，你如果想试一下，可以使用之前的斐波那契数列函数，如果 100 不会卡死的话就说明是有的。</p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<p>下面是一个正常的递归函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum(x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">100000</span>);</span><br><span class="line"><span class="comment">// Uncaught RangeError: Maximum call stack size exceeded(…)</span></span><br></pre></td></tr></table></figure>
<p>上面代码中， <code>sum</code> 是一个递归函数，参数 <code>x</code> 是需要累加的值，参数 <code>y</code> 控制递归次数。一旦指定 <code>sum</code> 递归 100000 次，就会报错，提示超出调用栈的最大次数。</p>
<p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (f &amp;&amp; f <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">    f = f();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾递归优化是通过减少在递归的时候使用的调用栈，所有的循环都可以使用递归去实现，同样递归也是可以通过循环去实现的，在上面的 <code>trampoline</code> 函数中，通过将函数 <code>f</code> 执行后返回一个函数 <code>f</code> ，然后再去执行，就不是在函数里面调用函数，避免了递归。 <code>while</code> 里面的判断是函数 <code>f</code> 不为空且他是一个函数，目的就是将递归产生的下一个函数独立出来，使得上一个运算函数被当做普通函数在运行完成后销毁调用栈。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum.bind(<span class="literal">null</span>, x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中， <code>sum</code> 函数的每次执行，都会返回自身的另一个版本。</p>
<p>现在，使用蹦床函数执行 <code>sum</code> ，就不会发生调用栈溢出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trampoline(sum(<span class="number">1</span>, <span class="number">100000</span>));</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure>
<p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tco</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> active = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> accumulated = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">accumulator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    accumulated.push(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (!active) &#123;</span><br><span class="line">      active = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (accumulated.length) &#123;</span><br><span class="line">        value = f.apply(<span class="built_in">this</span>, accumulated.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      active = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = tco(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum(x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">100000</span>);</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure>
<p>上面的实例代码是蹦床函数的升级版，同时也加入了柯里化的一些思想，通过 <code>active</code> 控制尾递归优化，通过 <code>accumulated</code> 来保存每一轮运行的参数。</p>
<blockquote>
<p><strong><code>apply()</code></strong> 方法调用一个具有给定 <code>this</code> 值的函数，以及作为一个数组（或<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects">类似数组对象</a>）提供的参数。</p>
</blockquote>
<p>回顾一下 <code>apply()</code> ，使用的作用和 <code>call()</code> 是一样的，但是 <code>apply()</code> 接受的是一个参数数组，这也是为什么这里 <code>accumulated</code> 是一个数组，然后用来保存 <code>arguments</code> 参数数组， <code>push</code> 和 <code>shift</code> 方法出来就是当前递归的两个参数，</p>
<p>使用 <code>while</code> 和其他感觉差别不大，但是由于 JavaScript 的单线程原因，我还真有点怕使用 <code>if</code> 等条件语句或者其他循环会导致语句并没有同步运行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.apply(<span class="built_in">this</span>, accumulated.shift());</span><br></pre></td></tr></table></figure>
<p>返回的 <code>sum(x+1,y-1)</code> ， 都会再次通过 <code>tco</code> 函数，进行柯里化。之前的函数已经运行完毕就被销毁了，除了 <code>tco</code> 函数因为具有柯里化的特性。</p>
<p>这样就把一个递归函数改成了具有柯里化特性的循环函数。通过 <code>apply()</code> 的特性去调用实际的计算函数。返回的结果由 <code>Value</code> 来接收并返回，作为下一次的 <code>tco</code> 函数的 <code>f</code> 参数。</p>
<h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p><code>...</code> 用于将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">&#x27;div&#x27;</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure>
<p>参数数列的意思是如果将它作为函数的参数，数组有几个就有几个参数传入。如果函数本身的参数比数组长度小的话多余的参数会被抛弃。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">    array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">push(a, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">a <span class="comment">// [1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>
<p>如果是在参数内容使用 <code>...</code> 会将后续的参数一起接收。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items, item</span>) </span>&#123;</span><br><span class="line">    array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Rest parameter must be last formal parameter</span></span><br></pre></td></tr></table></figure>
<p>如果使用 <code>...</code> 作为参数的话必须放到最后一位。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">v, w, x, y, z</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> args = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">f(-<span class="number">1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
<p>在调用函数使用 <code>...</code> 的时候也需要小心，注意数组的长度，最好也是作为最后一个参数组传入。如果传入的是空数组，则不会产生效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [...(x &gt; <span class="number">0</span> ? [<span class="string">&quot;a&quot;</span>] : []), <span class="string">&quot;b&quot;</span>];</span><br><span class="line"><span class="comment">// [&quot;a&quot;, &quot;b&quot;]</span></span><br></pre></td></tr></table></figure>
<p><code>...</code> 的优先级是比较低的，如果是表达式的话是会等表达式结束的。</p>
<p><strong>可以用来替代 <code>apply</code> 方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> allArgs = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            allArgs = allArgs.concat(args);</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, allArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add = currying(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;);</span><br><span class="line">作者： 我是leon</span><br><span class="line">链接： https: <span class="comment">//juejin.im/post/5b561426518825195f499772</span></span><br><span class="line">    来源： 掘金</span><br><span class="line">著作权归作者所有。 商业转载请联系作者获得授权， 非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>回顾之前的柯里化过程，通过 <code>allArgs</code> 数组保存每次传入参数后通过 <code>fn</code> 传入调用实际计算函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.apply(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure>
<p>不过改动的话只有 <code>fn.apply()</code> 这一句，具体区别的话可能不太大。对于一切工具函数需要传入数组作为参数时，使用 <code>...</code> 可以更加的简洁方便。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]);</span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>]);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br></pre></td></tr></table></figure>
<p>这里的关键是 <code>Math.max</code> 方法接收的是多个参数，而不是数组参数，所以通过 <code>apply()</code> 方法调用，传入数组参数。因为 <code>apply()</code> 方法本来就是接收数组参数，作为函数的参数时。相当于是内部实现了 <code>...</code> 方法。</p>
<p>阮一峰的这个入门里面还提了一个例子是数组相加，通过数组原生 <code>push</code> 方法的 <code>apply()</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5的 写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure>
<p>这个方法和原生的 <code>concat()</code> 方法不一样，因为 <code>concat()</code> 方法是返回一个新的数组，原来的两个数组都不会被修改。使用 <code>push.apply()</code> 是为了节省内存空间避免新生成数组。</p>
<p>然后就是数组的深拷贝，简单的 <code>a1=a2</code> 只是浅拷贝，ES5 环境下会使用 <code>concat()</code> 方法，返回 <code>a1</code> 的副本。使用扩展运算符就可以直接 <code>a2=[...a1]</code> 或者 <code>[...a2]=a1</code> ，虽然后面这种写法有点反人类，不过之前的函数调用就是这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数初始化的时候将后续的参数都赋值给 <code>items</code> 。</p>
<p>同理，如果是多个参数赋值，需要将扩展运算符放在最后一位</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, ...e] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line">e; <span class="comment">// [5,6,7]</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>...</code> 也可以将字符串变成数组，支持四个字节的 Unicode 字符解析。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&quot;hello&quot;</span>];</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure>
<p>背后的原理应该是 <code>iterator</code> 这么说的话可迭代的变量应该也是都可以使用扩展运算符的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&quot;one&quot;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&quot;two&quot;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&quot;three&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map.keys()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> go = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量 <code>go</code> 是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array. from()"></a>Array. from()</h4><p><code>Array.from</code> 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p>
<p>只要是部署了 Iterator 接口的数据结构， <code>Array.from</code> 都能将其转为数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> namesSet = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]);</span><br><span class="line"><span class="built_in">Array</span>.from(namesSet); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>扩展运算符背后调用的是遍历器接口（ <code>Symbol.iterator</code> ），如果一个对象没有部署这个接口，就无法转换。 <code>Array.from</code> 方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有 <code>length</code> 属性。因此，任何有 <code>length</code> 属性的对象，都可以通过 <code>Array.from</code> 方法转为数组，而此时扩展运算符就无法转换。</p>
<p>对于还没有部署该方法的浏览器，可以用 <code>Array.prototype.slice</code> 方法替代。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toArray = (<span class="function">() =&gt;</span></span><br><span class="line">  <span class="built_in">Array</span>.from ? <span class="built_in">Array</span>.from : <span class="function">(<span class="params">obj</span>) =&gt;</span> [].slice.call(obj))();</span><br></pre></td></tr></table></figure>
<p><code>Array.from</code> 还可以接受第二个参数，作用类似于数组的 <code>map</code> 方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike, <span class="function">(<span class="params">x</span>) =&gt;</span> x * x);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function">(<span class="params">x</span>) =&gt;</span> x * x);</span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x);</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure>
<h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array. of()"></a>Array. of()</h4><p><code>Array.of</code> 基本上可以用来替代 <code>Array()</code> 或 <code>new Array()</code> ，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(); <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="literal">undefined</span>); <span class="comment">// [undefined]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>); <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<h4 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h4><p>数组实例的 <code>copyWithin()</code> 方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, (start = <span class="number">0</span>), (end = <span class="built_in">this</span>.length));</span><br></pre></td></tr></table></figure>
<ul>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li>
</ul>
<p>所以需要复制的数组段是[start, end)，前闭后开，从 target 开始复制。</p>
<h4 id="find-和-findInedx"><a href="#find-和-findInedx" class="headerlink" title="find() 和 findInedx()"></a>find() 和 findInedx()</h4><p>数组实例的 <code>find</code> 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 <code>true</code> 的成员，然后返回该成员。如果没有符合条件的成员，则返回 <code>undefined</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>上面代码中， <code>find</code> 方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<p>数组实例的 <code>findIndex</code> 方法的用法与 <code>find</code> 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 <code>-1</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的 <code>this</code> 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v &gt; <span class="built_in">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line">[<span class="number">10</span>, <span class="number">12</span>, <span class="number">26</span>, <span class="number">15</span>].find(f, person); <span class="comment">// 26</span></span><br></pre></td></tr></table></figure>
<p>另外，这两个方法都可以发现 <code>NaN</code> ，弥补了数组的 <code>indexOf</code> 方法的不足。</p>
<blockquote>
<p>NaN 属性是代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对象设置为该值，来指示其不是数字值。</p>
<p><strong>提示：</strong>请使用 isNaN() 全局函数来判断一个值是否是 NaN 值。</p>
</blockquote>
<h4 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h4><p><code>fill</code> 方法使用给定值，填充一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>].fill(<span class="number">7</span>);</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>);</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure>
<p><code>fill</code> 方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<p>可以在声明数组时对数组进行初始化。</p>
<h4 id="entries-，-keys-和-values"><a href="#entries-，-keys-和-values" class="headerlink" title="entries() ， keys() 和 values()"></a><code>entries()</code> ， <code>keys()</code> 和 <code>values()</code></h4><p>ES6 提供三个新的方法—— <code>entries()</code> ， <code>keys()</code> 和 <code>values()</code> ——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用 <code>for...of</code> 循环进行遍历，唯一的区别是 <code>keys()</code> 是对键名的遍历、 <code>values()</code> 是对键值的遍历， <code>entries()</code> 是对键值对的遍历。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h4><p><code>includes()</code> 方法函数与 <code>indexOf()</code> 方法效果差不多，但是更加具有语义化，而且可以返回出现位置，同时内部使用了 <code>===</code> 可以判断 <code>NaN</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  .includes(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)].includes(<span class="number">4</span>) <span class="comment">// false</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>)].includes(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>该方法的第二个参数表示搜索的起始位置，默认为 <code>0</code> 。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为 <code>-4</code> ，但数组长度为 <code>3</code> ），则会重置为从 <code>0</code> 开始。</p>
<h4 id="flat-flatMap"><a href="#flat-flatMap" class="headerlink" title="flat(), flatMap()"></a>flat(), flatMap()</h4><p>数组的成员有时还是数组， <code>Array.prototype.flat()</code> 用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p>
<p>如果原数组有空位， <code>flat()</code> 方法会跳过空位。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].flat();</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p><code>flatMap()</code> 方法对原数组的每个成员执行一个函数（相当于执行 <code>Array.prototype.map()</code> ），然后对返回值组成的数组执行 <code>flat()</code> 方法。该方法返回一个新数组，不改变原数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>]);</span><br><span class="line"><span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure>
<h4 id="数组空位的处理"><a href="#数组空位的处理" class="headerlink" title="数组空位的处理"></a>数组空位的处理</h4><blockquote>
<p>ES6 则是明确将空位转为 <code>undefined</code> 。</p>
</blockquote>
<h4 id="Array-prototype-sort-排序稳定性"><a href="#Array-prototype-sort-排序稳定性" class="headerlink" title="Array. prototype. sort() 排序稳定性"></a>Array. prototype. sort() 排序稳定性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;peach&quot;</span>, <span class="string">&quot;straw&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;spork&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stableSorting = <span class="function">(<span class="params">s1, s2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (s1[<span class="number">0</span>] &lt; s2[<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">arr.sort(stableSorting);</span><br><span class="line"><span class="comment">// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码对数组 <code>arr</code> 按照首字母进行排序。排序结果中， <code>straw</code> 在 <code>spork</code> 的前面，跟原始顺序一致，所以排序算法 <code>stableSorting</code> 是稳定排序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unstableSorting = <span class="function">(<span class="params">s1, s2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (s1[<span class="number">0</span>] &lt;= s2[<span class="number">0</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">arr.sort(unstableSorting);</span><br><span class="line"><span class="comment">// [&quot;apple&quot;, &quot;peach&quot;, &quot;spork&quot;, &quot;straw&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，排序结果是 <code>spork</code> 在 <code>straw</code> 前面，跟原始顺序相反，所以排序算法 <code>unstableSorting</code> 是不稳定的。</p>
<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><h4 id="属性的简写方法"><a href="#属性的简写方法" class="headerlink" title="属性的简写方法"></a>属性的简写方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123;</span><br><span class="line">  foo,</span><br><span class="line">&#125;;</span><br><span class="line">baz; <span class="comment">// &#123;foo: &quot;bar&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过大括号包括的属性如果没有通过冒号赋值则会寻找同名的变量并赋值。</p>
<h4 id="对象属性定义"><a href="#对象属性定义" class="headerlink" title="对象属性定义"></a>对象属性定义</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">obj.foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">obj[<span class="string">&quot;a&quot;</span> + <span class="string">&quot;bc&quot;</span>] = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p>
<p>属性名表达式与简洁表示法，不能同时使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123;</span><br><span class="line">    [foo]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123;</span><br><span class="line">    [foo]: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h4><p>函数的 <code>name</code> 属性，返回函数名。对象方法也是函数，因此也有 <code>name</code> 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayName.name; <span class="comment">// &quot;sayName&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，方法的 <code>name</code> 属性返回函数名（即方法名）。</p>
<p>如果对象的方法使用了取值函数（ <code>getter</code> ）和存值函数（ <code>setter</code> ），则 <code>name</code> 属性不是在该方法上面，而是该方法的属性的描述对象的 <code>get</code> 和 <code>set</code> 属性上面，返回值是方法名前加上 <code>get</code> 和 <code>set</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">foo</span>() &#123;&#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">foo</span>(<span class="params">x</span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo.name;</span><br><span class="line"><span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">descriptor.get.name; <span class="comment">// &quot;get foo&quot;</span></span><br><span class="line">descriptor.set.name; <span class="comment">// &quot;set foo&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h4><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。 <code>Object.getOwnPropertyDescriptor</code> 方法可以获取该属性的描述对象。</p>
<p>描述对象的属性中的 <code>enumerable</code> 属性称为“可枚举性“，如果该属性的 <code>enumerable</code> 为 <code>false</code> 的话，就表示该属性不可被枚举，如果遇到 <code>for...in</code> <code>Object.keys()</code> <code>JSON.stringify()</code> <code>Object.assign()</code> 这类方法时，会跳过该属性。</p>
<p>这个属性在 <code>JavaScript</code> 内部实现时也是会经常用到的，可以用来规避一些隐性的属性被遍历。例如原生的方法或者数组的 <code>length</code> 属性等。另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。</p>
<blockquote>
<p>对象内的方法也算是对象的属性之一。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;</span><br><span class="line">  <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(a, <span class="string">&quot;method&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;value: ƒ, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><p>我们知道， <code>this</code> 关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字 <code>super</code> ，指向当前对象的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  foo: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">&quot;world&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">find</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.foo;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line">obj.find(); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>注意， <code>super</code> 关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="built_in">super</span>.foo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function">() =&gt;</span> <span class="built_in">super</span>.foo,</span><br><span class="line">  <span class="comment">// 是 foo: function()&#123;&#125; 的简写。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.foo;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面三种 <code>super</code> 的用法都会报错，因为对于 JavaScript 引擎来说，这里的 <code>super</code> 都没有用在对象的方法之中。第一种写法是 <code>super</code> 用在属性里面，第二种和第三种写法是 <code>super</code> 用在一个函数里面，然后赋值给 <code>foo</code> 属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。</p>
<h4 id="…-扩展运算符"><a href="#…-扩展运算符" class="headerlink" title="… 扩展运算符"></a>… 扩展运算符</h4><p>对象也使用了 <code>iterator</code> 属性，可以用 <code>...</code> 对其遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123;</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">2</span>,</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  b: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line">x; <span class="comment">// 1</span></span><br><span class="line">y; <span class="comment">// 2</span></span><br><span class="line">z; <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br><span class="line"><span class="keyword">let</span> o1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123;</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line">o2.__proto__ = o1;</span><br><span class="line"><span class="keyword">let</span> &#123; ...o3 &#125; = o2;</span><br><span class="line">o3; <span class="comment">// &#123; b: 2 &#125;</span></span><br><span class="line">o3.a; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象 o3 复制了 o2，但是只复制了 o2 自身的属性，没有复制它的原型对象 o1 的属性。</p>
<p>对象的扩展运算符（ <code>...</code> ）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<p>对象的扩展运算符等同于使用 <code>Object.assign()</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aClone = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aClone = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br></pre></td></tr></table></figure>
<h4 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="链判断运算符"></a>链判断运算符</h4><p>编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取 <code>message.body.user.firstName</code> ，安全的写法是写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName =</span><br><span class="line">  (message &amp;&amp;</span><br><span class="line">    message.body &amp;&amp;</span><br><span class="line">    message.body.user &amp;&amp;</span><br><span class="line">    message.body.user.firstName) ||</span><br><span class="line">  <span class="string">&quot;default&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>或者使用三元运算符 <code>?:</code> ，判断一个对象是否存在。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fooInput = myForm.querySelector(<span class="string">&quot;input[name=foo]&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fooValue = fooInput ? fooInput.value : <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
<p>这样的层层判断非常麻烦，因此 <a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-optional-chaining">ES2020</a> 引入了“链判断运算符”（optional chaining operator） <code>?.</code> ，简化上面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = message?.body?.user?.firstName || <span class="string">&quot;default&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> fooValue = myForm.querySelector(<span class="string">&quot;input[name=foo]&quot;</span>)?.value;</span><br></pre></td></tr></table></figure>
<p>上面代码使用了 <code>?.</code> 运算符，直接在链式调用的时候判断，左侧的对象是否为 <code>null</code> 或 <code>undefined</code> 。如果是的，就不再往下运算，而是返回 <code>undefined</code> 。</p>
<p>链判断运算符有三种用法。</p>
<ul>
<li><code>obj?.prop</code> // 对象属性</li>
<li><code>obj?.[expr]</code> // 同上</li>
<li><code>func?.(...args)</code> // 函数或对象方法的调用</li>
</ul>
<p>下面是这个运算符常见的使用形式，以及不使用该运算符时的等价形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a?.b;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.b;</span><br><span class="line">a?.[x];</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a[x];</span><br><span class="line">a?.b();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a.b();</span><br><span class="line">a?.();</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">a == <span class="literal">null</span> ? <span class="literal">undefined</span> : a();</span><br></pre></td></tr></table></figure>
<p>还有一些注意事项参考 <a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/object#%E9%93%BE%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6">链判断运算符</a></p>
<h4 id="Null-判断运算符"><a href="#Null-判断运算符" class="headerlink" title="Null 判断运算符"></a>Null 判断运算符</h4><p><code>null</code> 一般是指变量已声明但是没有初始化。</p>
<p>读取对象属性的时候，如果某个属性的值是 <code>null</code> 或 <code>undefined</code> ，有时候需要为它们指定默认值。常见做法是通过 <code>||</code> 运算符指定默认值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> headerText = response.settings.headerText || <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> animationDuration = response.settings.animationDuration || <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> showSplashScreen = response.settings.showSplashScreen || <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>上面的三行代码都通过 <code>||</code> 运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为 <code>null</code> 或 <code>undefined</code> ，默认值就会生效，但是属性的值如果为空字符串或 <code>false</code> 或 <code>0</code> ，默认值也会生效。</p>
<p>为了避免这种情况，<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-nullish-coalescing">ES2020</a> 引入了一个新的 Null 判断运算符 <code>??</code> 。它的行为类似 <code>||</code> ，但是只有运算符左侧的值为 <code>null</code> 或 <code>undefined</code> 时，才会返回右侧的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> headerText = response.settings.headerText ? ? <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> animationDuration = response.settings.animationDuration ? ? <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> showSplashScreen = response.settings.showSplashScreen ? ? <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，默认值只有在属性值为 <code>null</code> 或 <code>undefined</code> 时，才会生效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animationDuration = response.settings?.animationDuration ? ? <span class="number">300</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中， <code>response.settings</code> 如果是 <code>null</code> 或 <code>undefined</code> ，就会返回默认值 300。</p>
<p>可以使用该运算符判断配合 <code>?.</code> 运算符是否变量为 <code>null</code> 或者 <code>undefined</code> 并为其设定默认值。</p>
<p>** <code>??</code> 有一个运算优先级问题，它与 <code>&amp;&amp;</code> 和 <code>||</code> 的优先级孰高孰低。现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。**</p>
<h3 id="对象的新方法"><a href="#对象的新方法" class="headerlink" title="对象的新方法"></a>对象的新方法</h3><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects">MDN 关于 JavaScript 内置对象的文档</a></p>
<p>新增的方法有</p>
<ul>
<li><p><code>Object.is()</code></p>
<blockquote>
<p>它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>
</blockquote>
</li>
</ul>
<p>需要注意的是这个方法比较的是值，类似于 <code>==</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span>; <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>Object.assign()</code></p>
<blockquote>
<p><code>Object.assign</code> 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
</blockquote>
</li>
</ul>
<p>该方法之前也提到过，有同种效果的还包括 <code>...</code> 扩展运算符、 <code>concat()</code> ，只是各自的使用场景不同，而且 <code>assign()</code> 的主要使用参数是对象，如果目标不是对象会将其先转为对象，这也是为什么可以用在数组上的原因（包装对象）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123;</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123;</span><br><span class="line">  c: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target; <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>
<p>而且需要注意的是 <code>Object.assign()</code> 方法实行的是浅拷贝，而且在遇到两个对象的属性有重名现象的会优先替换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = <span class="number">2</span>;</span><br><span class="line">obj2.a.b; <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: <span class="string">&quot;c&quot;</span>,</span><br><span class="line">    d: <span class="string">&quot;e&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: &#x27;hello&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure>
<p><code>Object.assign</code> 只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">foo</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"><span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Object. getOwnPropertyDescriptors()</p>
<blockquote>
<p>ES5 的 <code>Object.getOwnPropertyDescriptor()</code> 方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了 <code>Object.getOwnPropertyDescriptors()</code> 方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">bar</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj);</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: get bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure>
<p>该方法的引入目的，主要是为了解决 <code>Object.assign()</code> 无法正确拷贝 <code>get</code> 属性和 <code>set</code> 属性的问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">foo</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target1, source);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(target1, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="comment">// &#123; value: undefined,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target2 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target2, <span class="built_in">Object</span>.getOwnPropertyDescriptors(source));</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(target2, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="comment">// &#123; get: undefined,</span></span><br><span class="line"><span class="comment">//   set: [Function: set foo],</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>另外， <code>Object.getOwnPropertyDescriptors()</code> 方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  __proto__: prot,</span><br><span class="line">  foo: <span class="number">123</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ES6 规定 <code>__proto__</code> 只有浏览器要部署，其他环境不用部署。如果去除 <code>__proto__</code> ，上面代码就要改成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(prot);</span><br><span class="line">obj.foo = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(prot), &#123;</span><br><span class="line">  foo: <span class="number">123</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>有了 <code>Object.getOwnPropertyDescriptors()</code> ，我们就有了另一种写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(</span><br><span class="line">  prot,</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(&#123;</span><br><span class="line">    foo: <span class="number">123</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>Object.getOwnPropertyDescriptors()</code> 也可以用来实现 Mixin（混入）模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mix = <span class="function">(<span class="params">object</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="keyword">with</span>: <span class="function">(<span class="params">...mixins</span>) =&gt;</span></span><br><span class="line">    mixins.reduce(</span><br><span class="line">      (c, mixin) =&gt; <span class="built_in">Object</span>.create(c, <span class="built_in">Object</span>.getOwnPropertyDescriptors(mixin)),</span><br><span class="line">      object</span><br><span class="line">    ),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// multiple mixins example</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  a: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">  b: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> c = &#123;</span><br><span class="line">  c: <span class="string">&quot;c&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> d = mix(c).with(a, b);</span><br><span class="line"></span><br><span class="line">d.c; <span class="comment">// &quot;c&quot;</span></span><br><span class="line">d.b; <span class="comment">// &quot;b&quot;</span></span><br><span class="line">d.a; <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Mixin 模式就是一些提供能够被一个或者一组子类简单继承功能的类, 意在重用其功能。</p>
</blockquote>
<p>简单说混入模式就是 JavaScript 独特的继承，通过原型链继承父对象的功能。可以参考 <a target="_blank" rel="noopener" href="https://zh.javascript.info/mixins">https://zh.javascript.info/mixins</a></p>
<ul>
<li><p>__proto__属性, Object. setPrototypeOf(), Object. getPrototypeOf()</p>
<blockquote>
<p>该属性没有写入 ES6 的正文，而是写入了附录，原因是 <code>__proto__</code> 前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的 <code>Object.setPrototypeOf()</code> （写操作）、 <code>Object.getPrototypeOf()</code> （读操作）、 <code>Object.create()</code> （生成操作）代替。</p>
</blockquote>
</li>
<li><p>Object. setPrototypeOf()</p>
<blockquote>
<p><code>Object.setPrototypeOf</code> 方法的作用与 <code>__proto__</code> 相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p>
</blockquote>
</li>
<li><p>Object. getPrototypeOf()</p>
<blockquote>
<p>该方法与 <code>Object.setPrototypeOf</code> 方法配套，用于读取一个对象的原型对象。</p>
</blockquote>
</li>
<li><p>Object. entries()</p>
<blockquote>
<p><code>Object.entries()</code> 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
</blockquote>
</li>
<li><p>Object. fromEntries()</p>
<blockquote>
<p><code>Object.fromEntries()</code> 方法是 <code>Object.entries()</code> 的逆操作，用于将一个键值对数组转为对象。</p>
</blockquote>
</li>
</ul>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>Symbol 是 ES6 新 引入的原始<strong>数据类型</strong>，用来表示独一无二的值。</p>
<p>感觉并没有什么大的用处，只能说是更加的语义化，通过 <code>Symbol</code> 生成的变量可以保证是唯一的，可能在大型项目中很有用。</p>
<p><code>Symbol</code> 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line"></span><br><span class="line">s1; <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2; <span class="comment">// Symbol(bar)</span></span><br><span class="line"></span><br><span class="line">s1.toString(); <span class="comment">// &quot;Symbol(foo)&quot;</span></span><br><span class="line">s2.toString(); <span class="comment">// &quot;Symbol(bar)&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>Symbol</code> 函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的 <code>Symbol</code> 函数的返回值是不相等的。</p>
<p>通常情况，会将 <code>Symbol</code> 值作为对象的属性名，保证不会出现同名的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&quot;Hello!&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123;</span><br><span class="line">  value: <span class="string">&quot;Hello!&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol]; <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码通过方括号结构和 <code>Object.defineProperty</code> ，将对象的属性名指定为一个 Symbol 值。</p>
<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.mySymbol = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">a[mySymbol]; <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">&quot;mySymbol&quot;</span>]; <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>
<p>在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在 <code>for...in</code> 、 <code>for...of</code> 循环中，也不会被 <code>Object.keys()</code> 、 <code>Object.getOwnPropertyNames()</code> 、 <code>JSON.stringify()</code> 返回。</p>
<p>但是，它也不是私有属性，有一个 <code>Object.getOwnPropertySymbols()</code> 方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">obj[b] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols;</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure>
<p>另一个新的 API， <code>Reflect.ownKeys()</code> 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&quot;my_key&quot;</span>)]: <span class="number">1</span>,</span><br><span class="line">  enum: <span class="number">2</span>,</span><br><span class="line">  nonEnum: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj);</span><br><span class="line"><span class="comment">//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</span></span><br></pre></td></tr></table></figure>
<h4 id="Symbol-的方法"><a href="#Symbol-的方法" class="headerlink" title="Symbol 的方法"></a>Symbol 的方法</h4><p><code>Symbol.for()</code></p>
<blockquote>
<p><code>symbol.for()</code> 方法可以重新使用同一个 <code>Symbol</code> 值，他会在已生成该 <code>Symbol</code> 值中搜索有没有参数一致的 <code>Symbol</code> 值，有就返回，没有就新建一个并<strong>注册到全局</strong></p>
</blockquote>
<p>普通的 <code>Symbol()</code> 方法生成的 Symbol 是不会注册到全局的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s1 === s2; <span class="comment">//false</span></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s1 === s3; <span class="comment">//false</span></span><br><span class="line"><span class="keyword">let</span> s4 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s2 === s4; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>所以如果确认某一个 Symbol 值会被多次使用，需要用到 for() 方法才能使得该值被全局注册。不然是不会相等的。</p>
<blockquote>
<p><code>Symbol.for()</code> 与 <code>Symbol()</code> 这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。 <code>Symbol.for()</code> 不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的 <code>key</code> 是否已经存在，如果不存在才会新建一个值。比如，如果你调用 <code>Symbol.for(&quot;cat&quot;)</code> 30 次，每次都会返回同一个 Symbol 值，但是调用 <code>Symbol(&quot;cat&quot;)</code> 30 次，会返回 30 个不同的 Symbol 值。</p>
</blockquote>
<p>由于 <code>Symbol()</code> 写法没有登记机制，所以每次调用都会返回一个不同的值。</p>
<p><code>Symbol.keyFor()</code> 方法返回一个已登记的 Symbol 类型值的 <code>key</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1); <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h4 id="通过-Symbol-来实现-Singleton-模式"><a href="#通过-Symbol-来实现-Singleton-模式" class="headerlink" title="通过 Symbol 来实现 Singleton 模式"></a><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/symbol#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%A8%A1%E5%9D%97%E7%9A%84-Singleton-%E6%A8%A1%E5%BC%8F">通过 Symbol 来实现 Singleton 模式</a></h4><blockquote>
<p>Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。也叫单例模式</p>
</blockquote>
<p>这个案例是首先设计的一个单例模式，如果 <code>global.foo</code> 不存在就 <code>new</code> 一个，然后通过 <code>module.exports</code> 绑定，在其他文件中加载目标模块时就会返回这个 <code>global.foo</code> ，但是在加载了该模块后， <code>global._foo</code> 是全局性的变量，加载后可以被修改。</p>
<p>为了保护模块内的全局变量不会被外部文件所修改，可以通过 <code>Symbol</code> 作为全局变量的变量标志符。</p>
<p>需要注意的是由于 <code>symbol.for()</code> 方法注册的变量标志符可以通过 <code>symbol.for()</code> 方法进行全局的搜索进而访问，所以还是可以修改。</p>
<h4 id="Symbol-的属性"><a href="#Symbol-的属性" class="headerlink" title="Symbol 的属性"></a>Symbol 的属性</h4><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p>
<p>这些方法相当于是使用 <code>Symbol</code> 重新设计了一下，比如 <code>instanceof</code> 方法实际调用的就是 <code>Symbol.hasInstance</code> 方法。</p>
<ul>
<li><p>Symbol. hasInstance === instanceof</p>
</li>
<li><p>Symbol. isConcatSpreadable</p>
<blockquote>
<p>对象的 <code>Symbol.isConcatSpreadable</code> 属性等于一个布尔值，表示该对象用于 <code>Array.prototype.concat()</code> 时，是否可以展开。</p>
</blockquote>
</li>
<li><p>Symbol. species</p>
<blockquote>
<p>对象的 <code>Symbol.species</code> 属性，指向一个构造函数。创建衍生对象时，会使用该属性。</p>
</blockquote>
</li>
<li><p>Symbol. match</p>
<blockquote>
<p>对象的 <code>Symbol.match</code> 属性，指向一个函数。当执行 <code>str.match(myObject)</code> 时，如果该属性存在，会调用它，返回该方法的返回值。</p>
</blockquote>
</li>
<li><p>Symbol. replace</p>
<blockquote>
<p>对象的 <code>Symbol.replace</code> 属性，指向一个方法，当该对象被 <code>String.prototype.replace</code> 方法调用时，会返回该方法的返回值。</p>
</blockquote>
</li>
<li><p>Symbol. search</p>
<blockquote>
<p>对象的 <code>Symbol.search</code> 属性，指向一个方法，当该对象被 <code>String.prototype.search</code> 方法调用时，会返回该方法的返回值。</p>
</blockquote>
</li>
<li><p>Symbol. split</p>
<blockquote>
<p>对象的 <code>Symbol.split</code> 属性，指向一个方法，当该对象被 <code>String.prototype.split</code> 方法调用时，会返回该方法的返回值。</p>
</blockquote>
</li>
<li><p>Symbol. iterator</p>
<blockquote>
<p>对象的 <code>Symbol.iterator</code> 属性，指向该对象的默认遍历器方法。</p>
</blockquote>
</li>
<li><p>Symbol. toPrimitive</p>
<blockquote>
<p>对象的 <code>Symbol.toPrimitive</code> 属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>
</blockquote>
</li>
<li><p>Symbol. toStringTag</p>
<blockquote>
<p>对象的 <code>Symbol.toStringTag</code> 属性，指向一个方法。在该对象上面调用 <code>Object.prototype.toString</code> 方法时，如果这个属性存在，它的返回值会出现在 <code>toString</code> 方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制 <code>[object Object]</code> 或 <code>[object Array]</code> 中 <code>object</code> 后面的那个字符串。</p>
</blockquote>
</li>
<li><p>Symbol. unscopables</p>
<blockquote>
<p>对象的 <code>Symbol.unscopables</code> 属性，指向一个对象。该对象指定了使用 <code>with</code> 关键字时，哪些属性会被 <code>with</code> 环境排除。</p>
</blockquote>
</li>
</ul>
<h3 id="Set-和-Map"><a href="#Set-和-Map" class="headerlink" title="Set 和 Map"></a>Set 和 Map</h3><blockquote>
<p>Set 和 Map 是<strong>数据结构</strong>。</p>
</blockquote>
<p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p><code>Set</code> 本身是一个构造函数，用来生成 Set 数据结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function">(<span class="params">x</span>) =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...new <span class="built_in">Set</span>(array)];</span><br></pre></td></tr></table></figure>
<p>上面的方法也可以用于，去除字符串里面的重复字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(<span class="string">&quot;ababbc&quot;</span>)].join(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>向 Set 加入值的时候，<strong>不会发生类型转换</strong>，所以 <code>5</code> 和 <code>&quot;5&quot;</code> 是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（ <code>===</code> ），主要的区别是向 Set 加入值时认为 <code>NaN</code> 等于自身，而精确相等运算符认为 <code>NaN</code> 不等于自身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">let</span> a = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">NaN</span>;</span><br><span class="line">set.add(a);</span><br><span class="line">set.add(b);</span><br><span class="line">set; <span class="comment">// Set &#123;NaN&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码向 Set 实例添加了两次 <code>NaN</code> ，但是只会加入一个。这表明，在 Set 内部，两个 <code>NaN</code> 是相等的。</p>
<p>对于对象来说，两个对象是不相等的。</p>
<h4 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h4><p>Set 结构的实例有以下属性。</p>
<ul>
<li><code>Set.prototype.constructor</code> ：构造函数，默认就是 <code>Set</code> 函数。</li>
<li><code>Set.prototype.size</code> ：返回 <code>Set</code> 实例的成员总数。</li>
</ul>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>
<ul>
<li><code>Set.prototype.add(value)</code> ：添加某个值，返回 Set 结构本身。</li>
<li><code>Set.prototype.delete(value)</code> ：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>Set.prototype.has(value)</code> ：返回一个布尔值，表示该值是否为 <code>Set</code> 的成员。</li>
<li><code>Set.prototype.clear()</code> ：清除所有成员，没有返回值。</li>
</ul>
<p>上面这些属性和方法的实例如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line"></span><br><span class="line">s.size; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.has(<span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">3</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s.delete(<span class="number">2</span>);</span><br><span class="line">s.has(<span class="number">2</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h4><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li><code>Set.prototype.keys()</code> ：返回键名的遍历器</li>
<li><code>Set.prototype.values()</code> ：返回键值的遍历器</li>
<li><code>Set.prototype.entries()</code> ：返回键值对的遍历器</li>
<li><code>Set.prototype.forEach()</code> ：使用回调函数遍历每个成员</li>
</ul>
<p>需要特别指出的是， <code>Set</code> 的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p>
<p>数组的 <code>map</code> 和 <code>filter</code> 方法也可以间接用于 Set 了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> x % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure>
<p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> b.has(x)));</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> !b.has(x)));</span><br><span class="line"><span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">ws.add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></span><br><span class="line">ws.add(<span class="built_in">Symbol</span>());</span><br><span class="line"><span class="comment">// TypeError: invalid value used in weak set</span></span><br></pre></td></tr></table></figure>
<p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<p>这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为 <code>0</code> ，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。</p>
<p>由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。</p>
<p>WeakSet 结构有以下三个方法。</p>
<ul>
<li>**WeakSet. prototype. add(value)**：向 WeakSet 实例添加一个新成员。</li>
<li>**WeakSet. prototype. delete(value)**：清除 WeakSet 实例的指定成员。</li>
<li>**WeakSet. prototype. has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li>
</ul>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line"></span><br><span class="line">data[element] = <span class="string">&quot;metadata&quot;</span>;</span><br><span class="line">data[<span class="string">&quot;[object HTMLDivElement]&quot;</span>]; <span class="comment">// &quot;metadata&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码原意是将一个 DOM 节点作为对象 <code>data</code> 的键，但是由于对象只接受字符串作为键名，所以 <code>element</code> 被自动转为字符串 <code>[object HTMLDivElement]</code> 。</p>
<p>Map 数据结构可以使用其他类型的值作为键。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  p: <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">m.set(o, <span class="string">&quot;content&quot;</span>);</span><br><span class="line">m.get(o); <span class="comment">// &quot;content&quot;</span></span><br><span class="line"></span><br><span class="line">m.has(o); <span class="comment">// true</span></span><br><span class="line">m.delete(o); <span class="comment">// true</span></span><br><span class="line">m.has(o); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码使用 Map 结构的 <code>set</code> 方法，将对象 <code>o</code> 当作 <code>m</code> 的一个键，然后又使用 <code>get</code> 方法读取这个键，接着使用 <code>delete</code> 方法删除了这个键。</p>
<p><code>Map</code> 构造函数接受数组作为参数，实际上执行的是下面的算法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [</span><br><span class="line">  [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Author&quot;</span>],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">items.forEach(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> map.set(key, value));</span><br></pre></td></tr></table></figure>
<p>本质就是通过 <code>iterator</code> 接口循环数组内容并使用 <code>map.set()</code> 方法添加进 map 中。</p>
<p>不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作 <code>Map</code> 构造函数的参数。这就是说， <code>Set</code> 和 <code>Map</code> 都可以用来生成新的 Map。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">map.set([<span class="string">&quot;a&quot;</span>], <span class="number">555</span>);</span><br><span class="line">map.get([<span class="string">&quot;a&quot;</span>]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码的 <code>set</code> 和 <code>get</code> 方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此 <code>get</code> 方法无法读取该键，返回 <code>undefined</code> 。</p>
<p>所以如果要取一个对象需要使用该对象的引用才行。</p>
<h4 id="Map-的属性和方法"><a href="#Map-的属性和方法" class="headerlink" title="Map 的属性和方法"></a>Map 的属性和方法</h4><ul>
<li><p><code>Map.size</code></p>
<blockquote>
<p><code>size</code> 属性返回 Map 结构的成员总数。</p>
</blockquote>
</li>
<li><p><code>Map.prototype.set(key, value)</code></p>
<blockquote>
<p><code>set</code> 方法设置键名 <code>key</code> 对应的键值为 <code>value</code> ，然后返回整个 Map 结构。如果 <code>key</code> 已经有值，则键值会被更新，否则就新生成该键。</p>
</blockquote>
</li>
<li><p><code>Map.prototype.get(key)</code></p>
<blockquote>
<p><code>get</code> 方法读取 <code>key</code> 对应的键值，如果找不到 <code>key</code> ，返回 <code>undefined</code> 。</p>
</blockquote>
</li>
<li><p><code>Map.prototype.has(key)</code></p>
<blockquote>
<p><code>has</code> 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p>
</blockquote>
</li>
<li><p><code>Map.prototype.delete(key)</code></p>
<blockquote>
<p><code>delete</code> 方法删除某个键，返回 <code>true</code> 。如果删除失败，返回 <code>false</code> 。</p>
</blockquote>
</li>
<li><p><code>Map.prototype.clear()</code></p>
<blockquote>
<p><code>clear</code> 方法清除所有成员，没有返回值。</p>
</blockquote>
</li>
<li><p><code>Map.prototype.keys()</code> ：返回键名的遍历器。</p>
</li>
<li><p><code>Map.prototype.values()</code> ：返回键值的遍历器。</p>
</li>
<li><p><code>Map.prototype.entries()</code> ：返回所有成员的遍历器。</p>
</li>
<li><p><code>Map.prototype.forEach()</code> ：遍历 Map 的所有成员。</p>
</li>
</ul>
<h4 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h4><p><strong>（1）Map 转为数组</strong></p>
<p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（ <code>...</code> ）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="literal">true</span>, <span class="number">7</span>).set(</span><br><span class="line">  &#123;</span><br><span class="line">    foo: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="string">&quot;abc&quot;</span>]</span><br><span class="line">);</span><br><span class="line">[...myMap];</span><br><span class="line"><span class="comment">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#x27;abc&#x27; ] ] ]</span></span><br></pre></td></tr></table></figure>
<p><strong>（2）数组 转为 Map</strong></p>
<p>将数组传入 Map 构造函数，就可以转为 Map。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="literal">true</span>, <span class="number">7</span>],</span><br><span class="line">  [</span><br><span class="line">    &#123;</span><br><span class="line">      foo: <span class="number">3</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="string">&quot;abc&quot;</span>],</span><br><span class="line">  ],</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// Map &#123;</span></span><br><span class="line"><span class="comment">//   true =&gt; 7,</span></span><br><span class="line"><span class="comment">//   Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>（3）Map 转为对象</strong></p>
<p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">&quot;yes&quot;</span>, <span class="literal">true</span>).set(<span class="string">&quot;no&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToObj(myMap);</span><br><span class="line"><span class="comment">// &#123; yes: true, no: false &#125;</span></span><br></pre></td></tr></table></figure>
<p>如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</p>
<p><strong>（4）对象转为 Map</strong></p>
<p>对象转为 Map 可以通过 <code>Object.entries()</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br></pre></td></tr></table></figure>
<p>此外，也可以自己实现一个转换函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToStrMap</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objToStrMap(&#123;</span><br><span class="line">  yes: <span class="literal">true</span>,</span><br><span class="line">  no: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Map &#123;&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>（5）Map 转为 JSON</strong></p>
<p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToJson</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(strMapToObj(strMap));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">&quot;yes&quot;</span>, <span class="literal">true</span>).set(<span class="string">&quot;no&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">strMapToJson(myMap);</span><br><span class="line"><span class="comment">// &#x27;&#123;&quot;yes&quot;:true,&quot;no&quot;:false&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToArrayJson</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="literal">true</span>, <span class="number">7</span>).set(</span><br><span class="line">  &#123;</span><br><span class="line">    foo: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="string">&quot;abc&quot;</span>]</span><br><span class="line">);</span><br><span class="line">mapToArrayJson(myMap);</span><br><span class="line"><span class="comment">// &#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>（6）JSON 转为 Map</strong></p>
<p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToStrMap</span>(<span class="params">jsonStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> objToStrMap(<span class="built_in">JSON</span>.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToStrMap(<span class="string">&#x27;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&#x27;</span>);</span><br><span class="line"><span class="comment">// Map &#123;&#x27;yes&#x27; =&gt; true, &#x27;no&#x27; =&gt; false&#125;</span></span><br></pre></td></tr></table></figure>
<p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToMap</span>(<span class="params">jsonStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">JSON</span>.parse(jsonStr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonToMap(<span class="string">&#x27;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&#x27;</span>);</span><br><span class="line"><span class="comment">// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; [&#x27;abc&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params">target, propKey, receiver</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">target, propKey, value, receiver</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;propKey&#125;</span>!`</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, propKey, value, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（ <code>get</code> ）和设置（ <code>set</code> ）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象 <code>obj</code> ，去读写它的属性，就会得到下面的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj.count = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line">++obj.count;</span><br><span class="line"><span class="comment">//  getting count!</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line"><span class="comment">//  2</span></span><br></pre></td></tr></table></figure>
<p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p>
<p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>
<p>Proxy 对象的所有用法，都是上面这种形式，不同的只是 <code>handler</code> 参数的写法。其中， <code>new Proxy()</code> 表示生成一个 <code>Proxy</code> 实例， <code>target</code> 参数表示所要拦截的目标对象， <code>handler</code> 参数也是一个对象，用来定制拦截行为。</p>
<p>下面是另一个拦截读取属性行为的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params">target, propKey</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">proxy.time; <span class="comment">// 35</span></span><br><span class="line">proxy.name; <span class="comment">// 35</span></span><br><span class="line">proxy.title; <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>
<p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p>
<ul>
<li>**get(target, propKey, receiver)**：拦截对象属性的读取，比如 <code>proxy.foo</code> 和 <code>proxy[&#39;foo&#39;]</code> 。</li>
<li>**set(target, propKey, value, receiver)**：拦截对象属性的设置，比如 <code>proxy.foo = v</code> 或 <code>proxy[&#39;foo&#39;] = v</code> ，返回一个布尔值。</li>
<li>**has(target, propKey)**：拦截 <code>propKey in proxy</code> 的操作，返回一个布尔值。</li>
<li>**deleteProperty(target, propKey)**：拦截 <code>delete proxy[propKey]</code> 的操作，返回一个布尔值。</li>
<li>**ownKeys(target)**：拦截 <code>Object.getOwnPropertyNames(proxy)</code> 、 <code>Object.getOwnPropertySymbols(proxy)</code> 、 <code>Object.keys(proxy)</code> 、 <code>for...in</code> 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 <code>Object.keys()</code> 的返回结果仅包括目标对象自身的可遍历属性。</li>
<li>**getOwnPropertyDescriptor(target, propKey)**：拦截 <code>Object.getOwnPropertyDescriptor(proxy, propKey)</code> ，返回属性的描述对象。</li>
<li>**defineProperty(target, propKey, propDesc)**：拦截 <code>Object.defineProperty(proxy, propKey, propDesc）</code> 、 <code>Object.defineProperties(proxy, propDescs)</code> ，返回一个布尔值。</li>
<li>**preventExtensions(target)**：拦截 <code>Object.preventExtensions(proxy)</code> ，返回一个布尔值。</li>
<li>**getPrototypeOf(target)**：拦截 <code>Object.getPrototypeOf(proxy)</code> ，返回一个对象。</li>
<li>**isExtensible(target)**：拦截 <code>Object.isExtensible(proxy)</code> ，返回一个布尔值。</li>
<li>**setPrototypeOf(target, proto)**：拦截 <code>Object.setPrototypeOf(proxy, proto)</code> ，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li>**apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如 <code>proxy(...args)</code> 、 <code>proxy.call(object, ...args)</code> 、 <code>proxy.apply(...)</code> 。</li>
<li>**construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如 <code>new proxy(...args)</code> 。</li>
</ul>
<p>这也是为什么 Vue3. 0 要用 Proxy 重写数据绑定和数据劫持了，通过 Proxy 可以实现更多的拦截方式和更大的拦截范围。</p>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p><code>Reflect</code> 对象与 <code>Proxy</code> 对象一样，也是 ES6 为了操作对象而提供的新 API。</p>
<p>其目的是将一些属于语言内部的方法逐渐从 <code>Object</code> 对象中抽离出来放入 <code>Reflect</code> 中，并且对于 <code>Object</code> 的方法进行优化，包括返回优化，使得方法在出错时返回 <code>false</code> 而不是直接抛出错误。</p>
<p>修改某些操作的方式，将其变成函数行为，而不是命令式。与 Proxy 对象配合，只要是 <code>Proxy</code> 对象的方法，就能在 <code>Reflect</code> 对象上找到对应的方法。这就让 <code>Proxy</code> 对象可以方便地调用对应的 <code>Reflect</code> 方法，完成默认行为，作为修改行为的基础。</p>
<p><code>Reflect</code> 对象一共有 13 个静态方法。</p>
<ul>
<li>Reflect. apply(target, thisArg, args)</li>
<li>Reflect. construct(target, args)</li>
<li>Reflect. get(target, name, receiver)</li>
<li>Reflect. set(target, name, value, receiver)</li>
<li>Reflect. defineProperty(target, name, desc)</li>
<li>Reflect. deleteProperty(target, name)</li>
<li>Reflect. has(target, name)</li>
<li>Reflect. ownKeys(target)</li>
<li>Reflect. isExtensible(target)</li>
<li>Reflect. preventExtensions(target)</li>
<li>Reflect. getOwnPropertyDescriptor(target, name)</li>
<li>Reflect. getPrototypeOf(target)</li>
<li>Reflect. setPrototypeOf(target, prototype)</li>
</ul>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise 是 ES6 所提出的异步编程的一种解决方案，所谓 <code>Promise</code> ，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p><code>Promise</code> 对象有以下两个特点。</p>
<p>（1）对象的状态不受外界影响。 <code>Promise</code> 对象代表一个异步操作，有三种状态： <code>pending</code> （进行中）、 <code>fulfilled</code> （已成功）和 <code>rejected</code> （已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 <code>Promise</code> 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。 <code>Promise</code> 对象的状态改变，只有两种可能：从 <code>pending</code> 变为 <code>fulfilled</code> 和从 <code>pending</code> 变为 <code>rejected</code> 。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 <code>Promise</code> 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<p>看之前的记录应该就行了。</p>
<h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><p>JavaScript 原有的表示“集合”的数据结构，主要是数组（ <code>Array</code> ）和对象（ <code>Object</code> ），ES6 又添加了 <code>Map</code> 和 <code>Set</code> 。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是 <code>Map</code> ， <code>Map</code> 的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p>
<p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
<p>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令 <code>for...of</code> 循环，Iterator 接口主要供 <code>for...of</code> 消费。</p>
<p>Iterator 的遍历过程是这样的。</p>
<p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p>
<p>（2）第一次调用指针对象的 <code>next</code> 方法，可以将指针指向数据结构的第一个成员。</p>
<p>（3）第二次调用指针对象的 <code>next</code> 方法，指针就指向数据结构的第二个成员。</p>
<p>（4）不断调用指针对象的 <code>next</code> 方法，直到它指向数据结构的结束位置。</p>
<p>每一次调用 <code>next</code> 方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含 <code>value</code> 和 <code>done</code> 两个属性的对象。其中， <code>value</code> 属性是当前成员的值， <code>done</code> 属性是一个布尔值，表示遍历是否结束。</p>
<p>下面是一个模拟 <code>next</code> 方法返回值的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]);</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length</span><br><span class="line">        ? &#123;</span><br><span class="line">            value: array[nextIndex++],</span><br><span class="line">            done: <span class="literal">false</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        : &#123;</span><br><span class="line">            value: <span class="literal">undefined</span>,</span><br><span class="line">            done: <span class="literal">true</span>,</span><br><span class="line">          &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个 <code>makeIterator</code> 函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组 <code>[&#39;a&#39;, &#39;b&#39;]</code> 执行这个函数，就会返回该数组的遍历器对象（即指针对象） <code>it</code> 。</p>
<p>指针对象的 <code>next</code> 方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用 <code>next</code> 方法，指针就会指向数组的下一个成员。第一次调用，指向 <code>a</code> ；第二次调用，指向 <code>b</code> 。</p>
<p><code>next</code> 方法返回一个对象，表示当前数据成员的信息。这个对象具有 <code>value</code> 和 <code>done</code> 两个属性， <code>value</code> 属性返回当前位置的成员， <code>done</code> 属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用 <code>next</code> 方法。</p>
<p>通过 <code>Iterator</code> 接口就可以遍历大部分的数据结构。</p>
<p>ES6 规定，默认的 Iterator 接口部署在数据结构的 <code>Symbol.iterator</code> 属性，或者说，一个数据结构只要具有 <code>Symbol.iterator</code> 属性，就可以认为是“可遍历的”（iterable）。 <code>Symbol.iterator</code> 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名 <code>Symbol.iterator</code> ，它是一个表达式，返回 <code>Symbol</code> 对象的 <code>iterator</code> 属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内（参见《Symbol》一章）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: <span class="number">1</span>,</span><br><span class="line">          done: <span class="literal">true</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，对象 <code>obj</code> 是可遍历的（iterable），因为具有 <code>Symbol.iterator</code> 属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有 <code>next</code> 方法。每次调用 <code>next</code> 方法，都会返回一个代表当前成员的信息对象，具有 <code>value</code> 和 <code>done</code> 两个属性。</p>
<p>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被 <code>for...of</code> 循环遍历。原因在于，这些数据结构原生部署了 <code>Symbol.iterator</code> 属性（详见下文），另外一些数据结构没有（比如对象）。凡是部署了 <code>Symbol.iterator</code> 属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p>
<p>原生具备 Iterator 接口的数据结构如下。</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p>下面的例子是数组的 <code>Symbol.iterator</code> 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iter.next(); <span class="comment">// &#123; value: &#x27;a&#x27;, done: false &#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123; value: &#x27;b&#x27;, done: false &#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123; value: &#x27;c&#x27;, done: false &#125;</span></span><br><span class="line">iter.next(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>默认情况下对象是没有默认部署 <code>Iterator</code> ，因为对象的属性遍历顺序是很难去默认设置的，需要开发者手动设置。</p>
<p>一个对象如果要具备可被 <code>for...of</code> 循环调用的 Iterator 接口，就必须在 <code>Symbol.iterator</code> 的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeIterator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">start, stop</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = start;</span><br><span class="line">    <span class="built_in">this</span>.stop = stop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="built_in">this</span>.value;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>.stop) &#123;</span><br><span class="line">      <span class="built_in">this</span>.value++;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: <span class="literal">false</span>,</span><br><span class="line">        value: value,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      done: <span class="literal">true</span>,</span><br><span class="line">      value: <span class="literal">undefined</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start, stop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> range(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历器对象除了具有 <code>next</code> 方法，还可以具有 <code>return</code> 方法和 <code>throw</code> 方法。如果你自己写遍历器对象生成函数，那么 <code>next</code> 方法是必须部署的， <code>return</code> 方法和 <code>throw</code> 方法是否部署是可选的。</p>
<p><code>return</code> 方法的使用场合是，如果 <code>for...of</code> 循环提前退出（通常是因为出错，或者有 <code>break</code> 语句），就会调用 <code>return</code> 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 <code>return</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLinesSync</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            done: <span class="literal">false</span>,</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">return</span>() &#123;</span><br><span class="line">          file.close();</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            done: <span class="literal">true</span>,</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个数据结构只要部署了 <code>Symbol.iterator</code> 属性，就被视为具有 iterator 接口，就可以用 <code>for...of</code> 循环遍历它的成员。也就是说， <code>for...of</code> 循环内部调用的是数据结构的 <code>Symbol.iterator</code> 方法。</p>
<p><code>for...of</code> 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如 <code>arguments</code> 对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。</p>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>
<p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是， <code>function</code> 关键字与函数名之间有一个星号；二是，函数体内部使用 <code>yield</code> 表达式，定义不同的内部状态（ <code>yield</code> 在英语里的意思就是“产出”）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;ending&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个 Generator 函数 <code>helloWorldGenerator</code> ，它内部有两个 <code>yield</code> 表达式（ <code>hello</code> 和 <code>world</code> ），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p>
<p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p>
<p>下一步，必须调用遍历器对象的 <code>next</code> 方法，使得指针移向下一个状态。也就是说，每次调用 <code>next</code> 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 <code>yield</code> 表达式（或 <code>return</code> 语句）为止。换言之，Generator 函数是分段执行的， <code>yield</code> 表达式是暂停执行的标记，而 <code>next</code> 方法可以恢复执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next();</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h4><p>由于 Generator 函数返回的遍历器对象，只有调用 <code>next</code> 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。 <code>yield</code> 表达式就是暂停标志。</p>
<p>遍历器对象的 <code>next</code> 方法的运行逻辑如下。</p>
<p>（1）遇到 <code>yield</code> 表达式，就暂停执行后面的操作，并将紧跟在 <code>yield</code> 后面的那个表达式的值，作为返回的对象的 <code>value</code> 属性值。</p>
<p>（2）下一次调用 <code>next</code> 方法时，再继续往下执行，直到遇到下一个 <code>yield</code> 表达式。</p>
<p>（3）如果没有再遇到新的 <code>yield</code> 表达式，就一直运行到函数结束，直到 <code>return</code> 语句为止，并将 <code>return</code> 语句后面的表达式的值，作为返回的对象的 <code>value</code> 属性值。</p>
<p>（4）如果该函数没有 <code>return</code> 语句，则返回的对象的 <code>value</code> 属性值为 <code>undefined</code> 。</p>
<p>需要注意的是， <code>yield</code> 表达式后面的表达式，只有当调用 <code>next</code> 方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">123</span> + <span class="number">456</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中， <code>yield</code> 后面的表达式 <code>123 + 456</code> ，不会立即求值，只会在 <code>next</code> 方法将指针移到这一句时，才会求值。</p>
<p>任意一个对象的 <code>Symbol.iterator</code> 方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p>
<p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的 <code>Symbol.iterator</code> 属性，从而使得该对象具有 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Generator 函数赋值给 <code>Symbol.iterator</code> 属性，从而使得 <code>myIterable</code> 对象具有了 Iterator 接口，可以被 <code>...</code> 运算符遍历了。</p>
<p>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有 <code>Symbol.iterator</code> 属性，执行后返回自身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g[<span class="built_in">Symbol</span>.iterator]() === g;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>yield</code> 表达式本身没有返回值，或者说总是返回 <code>undefined</code> 。 <code>next</code> 方法可以带一个参数，该参数就会被当作上一个 <code>yield</code> 表达式的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">if</span> (reset) &#123;</span><br><span class="line">      i = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = f();</span><br><span class="line"></span><br><span class="line">g.next(); <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next(<span class="literal">true</span>); <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br></pre></td></tr></table></figure>
<p>再看一个通过 <code>next</code> 方法的参数，向 Generator 函数内部输入值的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">dataConsumer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Started&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`1.<span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`2.<span class="subst">$&#123;<span class="keyword">yield</span>&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> genObj = dataConsumer();</span><br><span class="line">genObj.next();</span><br><span class="line"><span class="comment">// Started</span></span><br><span class="line">genObj.next(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">// 1. a</span></span><br><span class="line">genObj.next(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">// 2. b</span></span><br></pre></td></tr></table></figure>
<p><code>for...of</code> 循环可以自动遍历 Generator 函数运行时生成的 <code>Iterator</code> 对象，且此时不再需要调用 <code>next</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>
<h3 id="通过-Generator-完成异步"><a href="#通过-Generator-完成异步" class="headerlink" title="通过 Generator 完成异步"></a>通过 Generator 完成异步</h3><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p>
<p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>
<p>如果你需要几个异步程序块同步运行，可以使用 Promise 链进行操作，如果不能使用 Promise 链的话就只能将后面的程序使用 setTimeOut 延迟运行，当做是等待前面的异步程序完成。</p>
<h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p>
<ul>
<li>第一步，协程 <code>A</code> 开始执行。</li>
<li>第二步，协程 <code>A</code> 执行到一半，进入暂停，执行权转移到协程 <code>B</code> 。</li>
<li>第三步，（一段时间后）协程 <code>B</code> 交还执行权。</li>
<li>第四步，协程 <code>A</code> 恢复执行。</li>
</ul>
<p>上面流程的协程 <code>A</code> ，就是异步任务，因为它分成两段（或多段）执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asyncJob</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的函数 <code>asyncJob</code> 是一个协程，它的奥妙就在其中的 <code>yield</code> 命令。它表示执行到此处，执行权将交给其他协程。也就是说， <code>yield</code> 命令是异步两个阶段的分界线。</p>
<p>协程遇到 <code>yield</code> 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除 <code>yield</code> 命令，简直一模一样。</p>
<h4 id="协程的-Generator-实现"><a href="#协程的-Generator-实现" class="headerlink" title="协程的 Generator 实现"></a>协程的 Generator 实现</h4><p>通过 <code>yield</code> 命令的特性，结合 <code>Generator</code> ，使得函数每次遇到 <code>yield</code> 会返回后面的表达式并暂停，等待 <code>next</code> 操作。通过这样的方式实现异步。</p>
<p>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 <code>yield</code> 语句注明。Generator 函数的执行方法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next(); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器） <code>g</code> 。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针 <code>g</code> 的 <code>next</code> 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 <code>yield</code> 语句，上例是执行到 <code>x + 2</code> 为止。</p>
<p>换言之， <code>next</code> 方法的作用是分阶段执行 <code>Generator</code> 函数。每次调用 <code>next</code> 方法，会返回一个对象，表示当前阶段的信息（ <code>value</code> 属性和 <code>done</code> 属性）。 <code>value</code> 属性是 <code>yield</code> 语句后面表达式的值，表示当前阶段的值； <code>done</code> 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p>
<p>而且 <code>Generator</code> 函数可以通过 <code>next()</code> 向外和向内传输数据，并且可以手动抛出错误让 <code>Generator</code> 函数接收。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&quot;node-fetch&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">&quot;https://api.github.com/users/github&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了 <code>yield</code> 命令。</p>
<p>执行这段代码的方法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result = g.next();</span><br><span class="line"></span><br><span class="line">result.value</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.json();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    g.next(data);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用 <code>next</code> 方法（第二行），执行异步任务的第一阶段。由于 <code>Fetch</code> 模块返回的是一个 Promise 对象，因此要用 <code>then</code> 方法调用下一个 <code>next</code> 方法。</p>
<h4 id="Thunk-函数"><a href="#Thunk-函数" class="headerlink" title="Thunk 函数"></a>Thunk 函数</h4><blockquote>
<p>Thunk 函数是自动执行 Generator 函数的一种方法。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(x + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">thunk</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> thunk() * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数 f 的参数 <code>x + 5</code> 被一个函数替换了。凡是用到原参数的地方，对 <code>Thunk</code> 函数求值即可。</p>
<p>这就是 Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。</p>
<h4 id="JavaScript-语言的-Thunk-函数"><a href="#JavaScript-语言的-Thunk-函数" class="headerlink" title="JavaScript 语言的 Thunk 函数"></a>JavaScript 语言的 Thunk 函数</h4><p>JavaScript 语言是传值调用，它的 Thunk 函数含义有所不同。在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常版本的readFile（多参数版本）</span></span><br><span class="line">fs.readFile(fileName, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk版本的readFile（单参数版本）</span></span><br><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFile(fileName, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br></pre></td></tr></table></figure>
<p>上面代码中， <code>fs</code> 模块的 <code>readFile</code> 方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。</p>
<blockquote>
<p>有点柯里化的意思</p>
</blockquote>
<h4 id="Thunkify-模块"><a href="#Thunkify-模块" class="headerlink" title="Thunkify 模块"></a>Thunkify 模块</h4><p>使用方式如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">&quot;thunkify&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> read = thunkify(fs.readFile);</span><br><span class="line">read(<span class="string">&quot;package.json&quot;</span>)(<span class="function"><span class="keyword">function</span> (<span class="params">err, str</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Thunkify 的源码与上一节那个简单的转换器非常像。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">arguments</span>.length);</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; ++i) &#123;</span><br><span class="line">      args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> called;</span><br><span class="line"></span><br><span class="line">      args.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        done.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fn.apply(ctx, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        done(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的源码主要多了一个检查机制，变量 <code>called</code> 确保回调函数只运行一次。这样的设计与下文的 Generator 函数相关。请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = a + b;</span><br><span class="line">  callback(sum);</span><br><span class="line">  callback(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ft = thunkify(f);</span><br><span class="line"><span class="keyword">var</span> print = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>);</span><br><span class="line">ft(<span class="number">1</span>, <span class="number">2</span>)(print);</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于 <code>thunkify</code> 只允许回调函数执行一次，所以只输出一行结果。</p>
<p>以读取文件为例。下面的 Generator 函数封装了两个异步操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">&quot;thunkify&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> readFileThunk = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r1 = <span class="keyword">yield</span> readFileThunk(<span class="string">&quot;/etc/fstab&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r1.toString());</span><br><span class="line">  <span class="keyword">var</span> r2 = <span class="keyword">yield</span> readFileThunk(<span class="string">&quot;/etc/shells&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中， <code>yield</code> 命令用于将程序的执行权移出 Generator 函数，那么就需要一种方法，将执行权再交还给 Generator 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> gen = fn();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = gen.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line">    result.value(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>
<p>上面代码的 <code>run</code> 函数，就是一个 Generator 函数的自动执行器。内部的 <code>next</code> 函数就是 Thunk 的回调函数。 <code>next</code> 函数先将指针移到 Generator 函数的下一步（ <code>gen.next</code> 方法），然后判断 Generator 函数是否结束（ <code>result.done</code> 属性），如果没结束，就将 <code>next</code> 函数再传入 Thunk 函数（ <code>result.value</code> 属性），否则就直接退出。</p>
<p>不管内部有多少个异步操作，直接把 Generator 函数传入 <code>run</code> 函数即可。当然，前提是每一个异步操作，都要是 Thunk 函数，也就是说，跟在 <code>yield</code> 命令后面的必须是 Thunk 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">&quot;thunkify&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> readFileThunk = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFileThunk(<span class="string">&quot;fileA&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFileThunk(<span class="string">&quot;fileB&quot;</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="keyword">yield</span> readFileThunk(<span class="string">&quot;fileN&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数 <code>g</code> 封装了 <code>n</code> 个异步的读取文件操作，只要执行 <code>run</code> 函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p>
<h4 id="co-模块"><a href="#co-模块" class="headerlink" title="co 模块"></a>co 模块</h4><p>下面是一个 Generator 函数，用于依次读取两个文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&quot;/etc/fstab&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&quot;/etc/shells&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>co 模块可以让你不用编写 Generator 函数的执行器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">&quot;co&quot;</span>);</span><br><span class="line">co(gen);</span><br></pre></td></tr></table></figure>
<p>上面代码中，Generator 函数只要传入 <code>co</code> 函数，就会自动执行。</p>
<p><code>co</code> 函数返回一个 <code>Promise</code> 对象，因此可以用 <code>then</code> 方法添加回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">co(gen).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Generator 函数执行完成&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>
<p>两种方法可以做到这一点。</p>
<p>（1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</p>
<p>（2）Promise 对象。将异步操作包装成 Promise 对象，用 <code>then</code> 方法交回执行权。</p>
<p>co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的 <code>yield</code> 命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co，详见后文的例子。</p>
<p>首先，把 <code>fs</code> 模块的 <code>readFile</code> 方法包装成一个 Promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span> (<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&quot;/etc/fstab&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&quot;/etc/shells&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后，手动执行上面的 Generator 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next().value.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  g.next(data).value.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    g.next(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>手动执行其实就是用 <code>then</code> 方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = g.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line">    result.value.then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>
<p>上面代码中，只要 Generator 函数还没执行到最后一步， <code>next</code> 函数就调用自身，以此实现自动执行。</p>
<p>co 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p>
<p>首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在返回的 Promise 对象里面，co 先检查参数 <code>gen</code> 是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为 <code>resolved</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&quot;function&quot;</span>) gen = gen.call(ctx);</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">&quot;function&quot;</span>) <span class="keyword">return</span> resolve(gen);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，co 将 Generator 函数的内部指针对象的 <code>next</code> 方法，包装成 <code>onFulfilled</code> 函数。这主要是为了能够捕捉抛出的错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&quot;function&quot;</span>) gen = gen.call(ctx);</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">&quot;function&quot;</span>) <span class="keyword">return</span> resolve(gen);</span><br><span class="line"></span><br><span class="line">    onFulfilled();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.next(res);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      next(ret);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，就是关键的 <code>next</code> 函数，它会反复调用自身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</span><br><span class="line">  <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</span><br><span class="line">  <span class="keyword">return</span> onRejected(</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">&quot;You may only yield a function, promise, generator, array, or object, &quot;</span> +</span><br><span class="line">        <span class="string">&#x27;but the following object was passed: &quot;&#x27;</span> +</span><br><span class="line">        <span class="built_in">String</span>(ret.value) +</span><br><span class="line">        <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中， <code>next</code> 函数的内部代码，一共只有四行命令。</p>
<p>第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</p>
<p>第二行，确保每一步的返回值，是 Promise 对象。</p>
<p>第三行，使用 <code>then</code> 方法，为返回值加上回调函数，然后通过 <code>onFulfilled</code> 函数再次调用 <code>next</code> 函数。</p>
<p>第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 <code>rejected</code> ，从而终止执行。</p>
<h3 id="Async-函数"><a href="#Async-函数" class="headerlink" title="Async 函数"></a>Async 函数</h3><p>Async/await 本质上是 Generator 的语法糖，可以更加直观的设计异步程序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span> (<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&quot;/etc/fstab&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&quot;/etc/shells&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码的函数 <code>gen</code> 可以写成 <code>async</code> 函数，就是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">&quot;/etc/fstab&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">&quot;/etc/shells&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一比较就会发现， <code>async</code> 函数就是将 Generator 函数的星号（ <code>*</code> ）替换成 <code>async</code> ，将 <code>yield</code> 替换成 <code>await</code> ，仅此而已。</p>
<p>转换后的 <code>async</code> 函数也会自动进行流程管理。</p>
<p><code>async</code> 函数对 Generator 函数的改进，体现在以下四点。</p>
<p>（1）内置执行器。</p>
<p>Generator 函数的执行必须靠执行器，所以才有了 <code>co</code> 模块，而 <code>async</code> 函数自带执行器。也就是说， <code>async</code> 函数的执行，与普通函数一模一样，只要一行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure>
<p>上面的代码调用了 <code>asyncReadFile</code> 函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用 <code>next</code> 方法，或者用 <code>co</code> 模块，才能真正执行，得到最后结果。</p>
<p>（2）更好的语义。</p>
<p><code>async</code> 和 <code>await</code> ，比起星号和 <code>yield</code> ，语义更清楚了。 <code>async</code> 表示函数里有异步操作， <code>await</code> 表示紧跟在后面的表达式需要等待结果。</p>
<p>（3）更广的适用性。</p>
<p><code>co</code> 模块约定， <code>yield</code> 命令后面只能是 Thunk 函数或 Promise 对象，而 <code>async</code> 函数的 <code>await</code> 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p>
<p>（4）返回值是 Promise。</p>
<p><code>async</code> 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用 <code>then</code> 方法指定下一步的操作。</p>
<p>进一步说， <code>async</code> 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 <code>await</code> 命令就是内部 <code>then</code> 命令的语法糖。</p>
<p><code>await</code> 命令后面的 Promise 对象如果变为 <code>reject</code> 状态，则 <code>reject</code> 的参数会被 <code>catch</code> 方法的回调函数接收到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">  .then(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">  .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>
<p>注意，上面代码中， <code>await</code> 语句前面没有 <code>return</code> ，但是 <code>reject</code> 方法的参数依然传入了 <code>catch</code> 方法的回调函数。这里如果在 <code>await</code> 前面加上 <code>return</code> ，效果是一样的。</p>
<p>任何一个 <code>await</code> 语句后面的 Promise 对象变为 <code>reject</code> 状态，那么整个 <code>async</code> 函数都会中断执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;hello world&quot;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="按顺序完成异步操作"><a href="#按顺序完成异步操作" class="headerlink" title="按顺序完成异步操作"></a><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/async#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%AE%8C%E6%88%90%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C">按顺序完成异步操作</a></h4><h3 id="Class-的基本语法"><a href="#Class-的基本语法" class="headerlink" title="Class 的基本语法"></a>Class 的基本语法</h3><p>JavaScript 确实是一门面向对象的编程语言，那么他也应该会有面向对象的三个特性，继承、多态、封装。</p>
<p>生成一个实例对象的传统方法是通过构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x = x;</span><br><span class="line">  <span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="built_in">this</span>.x + <span class="string">&quot;, &quot;</span> + <span class="built_in">this</span>.y + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>在这个例子中通过 <code>new</code> 标识符新建了 Point 函数的对象。</p>
<p><code>class</code> 作为 ES6 的一个语法糖，用来更加语义化的声明一个类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="built_in">this</span>.x + <span class="string">&quot;, &quot;</span> + <span class="built_in">this</span>.y + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>constructor</code> 是默认的构造方法，用于在对象被 <code>new</code> 实例化时的初始化。</p>
<p>定义“类”的方法的时候，前面不需要加上 <code>function</code> 这个关键字，直接把函数定义放进去了就可以了。</p>
<p>类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>
<p>他们的 <code>enumerable</code> 属性为 false。</p>
<p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在 <code>this</code> 对象上），否则都是定义在原型上（即定义在 <code>class</code> 上）。</p>
<p>也就是说大部分的对象方法是定义在对象的原型属性上的，即 <code>__proto__</code></p>
<p>与函数一样，类也可以使用表达式的形式定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">getClassName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是 <code>Me</code> ，但是 <code>Me</code> 只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用 <code>MyClass</code> 引用。</p>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 <code>static</code> 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod(); <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod();</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure>
<p>父类的静态方法，可以被子类继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod(); <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>
<p>静态属性指的是 Class 本身的属性，即 <code>Class.propName</code> ，而不是定义在实例对象（ <code>this</code> ）上的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line">Foo.prop; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面的写法为 <code>Foo</code> 类定义了一个静态属性 <code>prop</code> 。</p>
<p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-class-fields">提案</a>提供了类的静态属性，写法是在实例属性的前面，加上 <code>static</code> 关键字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myStaticProp = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(MyClass.myStaticProp); <span class="comment">// 42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。</p>
<p>一种做法是在命名上加以区别。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params">baz</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._bar(baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  <span class="function"><span class="title">_bar</span>(<span class="params">baz</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.snaf = baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中， <code>_bar</code> 方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p>
<p>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params">baz</span>)</span> &#123;</span><br><span class="line">    bar.call(<span class="built_in">this</span>, baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">this</span>.snaf = baz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种方法是利用 <code>Symbol</code> 值的唯一性，将私有方法的名字命名为一个 <code>Symbol</code> 值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="built_in">Symbol</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> snaf = <span class="built_in">Symbol</span>(<span class="string">&quot;snaf&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params">baz</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[bar](baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  [bar](baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>[snaf] = baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>Symbol</code> 的特性，阻止外部函数访问内部变量。以达成私有方法的实现。</p>
<p><code>new</code> 是从构造函数生成实例对象的命令。ES6 为 <code>new</code> 命令引入了一个 <code>new.target</code> 属性，该属性一般用在构造函数之中，返回 <code>new</code> 命令作用于的那个构造函数。如果构造函数不是通过 <code>new</code> 命令或 <code>Reflect.construct()</code> 调用的， <code>new.target</code> 会返回 <code>undefined</code> ，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.target !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;必须使用 new 命令生成实例&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;必须使用 new 命令生成实例&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>); <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">&quot;张三&quot;</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>上面代码确保构造函数只能通过 <code>new</code> 命令调用。</p>
<h3 id="Class-的继承"><a href="#Class-的继承" class="headerlink" title="Class 的继承"></a>Class 的继承</h3><p>Class 可以通过 <code>extends</code> 关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个 <code>ColorPoint</code> 类，该类通过 <code>extends</code> 关键字，继承了 <code>Point</code> 类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 <code>Point</code> 类。下面，我们在 <code>ColorPoint</code> 内部加上代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y, color</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.color + <span class="string">&quot; &quot;</span> + <span class="built_in">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中， <code>constructor</code> 方法和 <code>toString</code> 方法之中，都出现了 <code>super</code> 关键字，它在这里表示父类的构造函数，用来新建父类的 <code>this</code> 对象。</p>
<p>子类必须在 <code>constructor</code> 方法中调用 <code>super</code> 方法，否则新建实例时会报错。这是因为子类自己的 <code>this</code> 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 <code>super</code> 方法，子类就得不到 <code>this</code> 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cp = <span class="keyword">new</span> ColorPoint(); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>上面代码中， <code>ColorPoint</code> 继承了父类 <code>Point</code> ，但是它的构造函数没有调用 <code>super</code> 方法，导致新建实例时报错。</p>
<p><code>Object.getPrototypeOf</code> 方法可以用来从子类上获取父类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(ColorPoint) === Point;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<p><code>super</code> 这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p>
<p>第一种情况， <code>super</code> 作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次 <code>super</code> 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，子类 <code>B</code> 的构造函数之中的 <code>super()</code> ，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p>
<p>注意， <code>super</code> 虽然代表了父类 <code>A</code> 的构造函数，但是返回的是子类 <code>B</code> 的实例，即 <code>super</code> 内部的 <code>this</code> 指的是 <code>B</code> 的实例，因此 <code>super()</code> 在这里相当于 <code>A.prototype.constructor.call(this)</code></p>
<p>大多数浏览器的 ES5 实现之中，每一个对象都有 <code>__proto__</code> 属性，指向对应的构造函数的 <code>prototype</code> 属性。Class 作为构造函数的语法糖，同时有 <code>prototype</code> 属性和 <code>__proto__</code> 属性，因此同时存在两条继承链。</p>
<p>（1）子类的 <code>__proto__</code> 属性，表示构造函数的继承，总是指向父类。</p>
<p>（2）子类 <code>prototype</code> 属性的 <code>__proto__</code> 属性，表示方法的继承，总是指向父类的 <code>prototype</code> 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">B.__proto__ === A; <span class="comment">// true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，子类 <code>B</code> 的 <code>__proto__</code> 属性指向父类 <code>A</code> ，子类 <code>B</code> 的 <code>prototype</code> 属性的 <code>__proto__</code> 属性指向父类 <code>A</code> 的 <code>prototype</code> 属性。</p>
<p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  a: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  b: <span class="string">&quot;b&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  ...b,</span><br><span class="line">&#125;; <span class="comment">// &#123;a: &#x27;a&#x27;, b: &#x27;b&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中， <code>c</code> 对象是 <code>a</code> 对象和 <code>b</code> 对象的合成，具有两者的接口。</p>
<p>下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span>(<span class="params">...mixins</span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Mix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins) &#123;</span><br><span class="line">        copyProperties(<span class="built_in">this</span>, <span class="keyword">new</span> mixin()); <span class="comment">// 拷贝实例属性</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> mixin <span class="keyword">of</span> mixins) &#123;</span><br><span class="line">    copyProperties(Mix, mixin); <span class="comment">// 拷贝静态属性</span></span><br><span class="line">    copyProperties(Mix.prototype, mixin.prototype); <span class="comment">// 拷贝原型属性</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Mix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyProperties</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(source)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="string">&quot;constructor&quot;</span> &amp;&amp; key !== <span class="string">&quot;prototype&quot;</span> &amp;&amp; key !== <span class="string">&quot;name&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, key);</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(target, key, desc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的 <code>mix</code> 函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p>
<h3 id="Module（模块）的语法"><a href="#Module（模块）的语法" class="headerlink" title="Module（模块）的语法"></a>Module（模块）的语法</h3><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure>
<p>上面代码的实质是整体加载 <code>fs</code> 模块（即加载 <code>fs</code> 的所有方法），生成一个对象（ <code>_fs</code> ），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>
<p>ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，再通过 <code>import</code> 命令输入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">&quot;fs&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码的实质是从 <code>fs</code> 模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>
<p>模块功能主要由两个命令构成： <code>export</code> 和 <code>import</code> 。 <code>export</code> 命令用于规定模块的对外接口， <code>import</code> 命令用于输入其他模块提供的功能。</p>
<p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用 <code>export</code> 关键字输出该变量。下面是一个 JS 文件，里面使用 <code>export</code> 命令输出变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">&quot;Michael&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">&quot;Jackson&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">&quot;Michael&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">&quot;Jackson&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; firstName, lastName, year &#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码是 <code>profile.js</code> 文件，保存了用户信息。ES6 将其视为一个模块，里面用 <code>export</code> 命令对外部输出了三个变量。</p>
<p>也就是说如果你需要这三个变量，就可以使用 <code>import</code> 命令导入该模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; firstName, lastName, year &#125; <span class="keyword">from</span> <span class="string">&quot;profile.js&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><code>import</code> 命令加载的变量是<strong>只读</strong>的，具有提升效果，会提升到整个模块的头部，首先执行。</p>
<p>由于 <code>import</code> 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p>
<p>需要特别注意的是， <code>export</code> 命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    m</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    n <span class="keyword">as</span> m</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样的， <code>function</code> 和 <code>class</code> 的输出，也必须遵守这样的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    f</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除了指定加载某个输出值，还可以使用整体加载，即用星号（ <code>*</code> ）指定一个对象，所有输出值都加载在这个对象上面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">&quot;./circle&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;圆面积：&quot;</span> + circle.area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;圆周长：&quot;</span> + circle.circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure>
<p>使用 <code>export default</code> 命令，为模块指定默认输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&quot;my_module&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&quot;my_module&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中， <code>export</code> 和 <code>import</code> 语句可以结合在一起，写成一行。但需要注意的是，写成一行以后， <code>foo</code> 和 <code>bar</code> 实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用 <code>foo</code> 和 <code>bar</code> 。</p>
<p>本书介绍 <code>const</code> 命令的时候说过， <code>const</code> 声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants.js 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> B = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> C = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.js 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">&quot;./constants&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(constants.A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(constants.B); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test2.js 模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; A, B &#125; <span class="keyword">from</span> <span class="string">&quot;./constants&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(B); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>如果要使用的常量非常多，可以建一个专门的 <code>constants</code> 目录，将各种常量写在不同的文件里面，保存在该目录下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/db.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> db = &#123;</span><br><span class="line">  url: <span class="string">&quot;http://my.couchdbserver.local:5984&quot;</span>,</span><br><span class="line">  admin_username: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">  admin_password: <span class="string">&quot;admin password&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constants/user.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> users = [<span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>, <span class="string">&quot;staff&quot;</span>, <span class="string">&quot;ceo&quot;</span>, <span class="string">&quot;chief&quot;</span>, <span class="string">&quot;moderator&quot;</span>];</span><br></pre></td></tr></table></figure>
<p>然后，将这些文件输出的常量，合并在 <code>index.js</code> 里面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/index.js</span></span><br><span class="line"><span class="keyword">export</span> &#123; db &#125; <span class="keyword">from</span> <span class="string">&quot;./db&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; users &#125; <span class="keyword">from</span> <span class="string">&quot;./users&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>使用的时候，直接加载 <code>index.js</code> 就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; db, users &#125; <span class="keyword">from</span> <span class="string">&quot;./constants/index&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p>防抖指的是事件在发生后 n 秒内只能执行一次，如果事件在 n 秒内重复触发，会重置时间。也就是发生后如果 n 秒内再次触发，n 会重新计时，不会再次触发函数，如果 n 秒后没有触发事件，就自动触发事件（这个可触发可以不触发），关键在于不让目标事件在一段时间内重复多次触发。</p>
<p>具体的实现方法可以考虑两种，一种是类似点击这种事件，可以通过设置不可点击或者隐藏按钮的方法不让用户触发事件，另一种是在事件触发函数中设置 timeout 延迟触发，如果用户多次触发就重置时间。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>; <span class="comment">//借助闭包</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(fn, delay); <span class="comment">// 简化写法</span></span><br><span class="line">    <span class="comment">// 不管timer是否有效，都会在最后执行一次，如果有效的话就对应了在时间内重复触发，就会直接被clear掉，然后在最后一次触发的时候settimeout执行函数。无效的话也会在最后一次触发的时候settimeout执行函数。</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后是旧代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showTop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;滚动条位置：&quot;</span> + scrollTop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onscroll = debounce(showTop, <span class="number">1000</span>); <span class="comment">// 为了方便观察效果我们取个大点的间断值，实际使用根据需要来配置</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018428170">https://segmentfault.com/a/1190000018428170</a> 的实例代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.apply(context, args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">    <span class="comment">// 使用fn.apply() 和将方法传入settimeout是一样的，但是这样的形式可以动态传入参数。</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    <span class="keyword">let</span> callNow = !timeout;</span><br><span class="line">    <span class="comment">// 是否是第一次执行</span></span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">    &#125;, wait);</span><br><span class="line">    <span class="keyword">if</span> (callNow) func.apply(context, args);</span><br><span class="line">    <span class="comment">// 第一次执行的时候是直接执行，后面多次执行都会被延迟防抖。</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc </span>函数防抖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>func 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>wait 延迟执行毫秒数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>immediate true 表立即执行，false 表非立即执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    <span class="comment">// 通过 immediate 参数控制是否采用第一次立即执行</span></span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) func.apply(context, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c8b86b09daf0">https://www.jianshu.com/p/c8b86b09daf0</a> 的实例代码</p>
<p>相对来讲的话，简书的这个文章的代码更加完整而且可控。</p>
<p>节流的意思是，短时间内大量触发的事件，在函数执行一次后，函数在一段时间内不再执行，但是时间过后可以再次执行，并不会重置计时。</p>
<p>相对于防抖来说，节流的主要目的是在防止函数的多次运行后保证了函数的有效连续运行。比如思否的这个文章中的滚动条就更加适合使用节流，而不是防抖。因为用户如果一直在滚动的话，是不会在特定的时间加载或者执行动画的。而如果是节流的话，相当于是 setInterval() 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> valid = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">      <span class="comment">//休息时间 暂不接客</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 工作时间，执行函数并且在间隔期内把状态位设为无效</span></span><br><span class="line">    valid = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn();</span><br><span class="line">      valid = <span class="literal">true</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 请注意，节流函数并不止上面这种实现方案,</span></span><br><span class="line"><span class="comment">   例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。</span></span><br><span class="line"><span class="comment">   也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间戳版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="comment">// 通过设定时间戳来判断是否已经超出设定的间隔时间。</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">      func.apply(context, args);</span><br><span class="line">      previous = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">content.onmousemove = throttle(count, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计时器版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">// 通过timeout变量检测是否超出时间</span></span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">      timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 这里已经重置null了</span></span><br><span class="line">        func.apply(context, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc </span>函数节流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>func 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>wait 延迟执行毫秒数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>type 1 表时间戳版，2 表定时器版</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">        func.apply(context, args);</span><br><span class="line">        previous = now;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          timeout = <span class="literal">null</span>;</span><br><span class="line">          func.apply(context, args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="TypeScript-整理"><a href="#TypeScript-整理" class="headerlink" title="TypeScript 整理"></a>TypeScript 整理</h1><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h1 id="关于浏览器需要知道些什么"><a href="#关于浏览器需要知道些什么" class="headerlink" title="关于浏览器需要知道些什么"></a>关于浏览器需要知道些什么</h1><p>浏览器到底做了什么？</p>
<p>浏览器会管理与每个网站服务器的链接</p>
<ul>
<li>HTTP</li>
<li>HTTPS</li>
</ul>
<p>对应不同的链接方式，虽然都是基于 TCP 的，但是 HTTPS 使用了 SSL 或 TLS 协议为数据进行加密。</p>
<p>浏览器通过 URL 获取网页，URL 包含</p>
<ul>
<li>域名</li>
<li>资源路径</li>
</ul>
<p>域名通过 DNS 服务器获取网页服务器 IP，当然为了节省资源一般浏览器是有缓存的，或者操作系统会有缓存。</p>
<p>然后在通过资源路径获取到网页。</p>
<p>获取到网页后开始对网页进行解析和渲染</p>
<p>解析包括生成 HTML DOM 树和 CSS DOM 树，DOM 树是通过 HTML 语言的特性，将 HTML 代码变成一个个节点并连接成树，CSS 也同样如此，整合到一起后生成渲染树，然后通过浏览器内核对渲染树进行渲染展示出页面。</p>
<img src="/images/161bb3c9b220f8cb." class="img" title="png">

<p>浏览器集成了各种解析器，用于解析 HTML、CSS、JavaScript、PHP 等语言，由于各种语言版本和浏览器版本的不同，可能会出现某些浏览器不能使用某些特性，比如 ECMAScript 是 JavaScript 的标准，但是具体的实现是交给浏览器来做的，如果当前版本的浏览器没有做某个特性，可能就会导致网页显示错误或排版混乱。所以在前端页面的编写和优化过程中，对于兼容性有特殊要求的功能需要非常小心。</p>
<h1 id="Node-js-整理"><a href="#Node-js-整理" class="headerlink" title="Node. js 整理"></a>Node. js 整理</h1><h1 id="Vue-整理"><a href="#Vue-整理" class="headerlink" title="Vue 整理"></a>Vue 整理</h1><h2 id="Vue-是什么？"><a href="#Vue-是什么？" class="headerlink" title="Vue 是什么？"></a>Vue 是什么？</h2><p>Vue 是一个开源的响应式前端框架，使用了 MVVM 框架，方便开发者关注数据图层。</p>
<h3 id="MVVM-框架是什么？"><a href="#MVVM-框架是什么？" class="headerlink" title="MVVM 框架是什么？"></a>MVVM 框架是什么？</h3><p>Model-View-ViewModel 是 MVC 的一个改进版本。那么 MVC 又是什么？</p>
<p>Model-View-Controller，Model 是指数据模型，View 指视图，Controller 是控制器，这个框架使得视图和数据模型分开来，通过控制器来进行操作，在数据发生改变的时候通知控制器，然后控制器去更新视图。</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/mvc-pattern.html">https://www.runoob.com/design-pattern/mvc-pattern.html</a> 菜鸟的这个示例实现了一个 MVC 架构的程序。</p>
<p>MVVM 就是将 MVC 中的 Controller 改进成 ViewModel，把 Model 和 View 关联起来的就是 ViewModel。ViewModel 负责把 Model 的数据同步到 View 显示出来，还负责把 View 的修改同步回 Model。</p>
<blockquote>
<p>让 MVVM 框架去自动更新 DOM 的状态，从而把开发者从操作 DOM 的繁琐步骤中解脱出来！</p>
<p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1022910821149312/1108898947791072">https://www.liaoxuefeng.com/wiki/1022910821149312/1108898947791072</a></p>
</blockquote>
<h2 id="Vue-是如何实现响应式的？"><a href="#Vue-是如何实现响应式的？" class="headerlink" title="Vue 是如何实现响应式的？"></a>Vue 是如何实现响应式的？</h2><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"> <code>Object.defineProperty()</code> </a></p>
<p>一开始我觉得通过这个方法，就可以自定义 get() 和 set() 两个方法，这样当这个数据对象发生改变或者获取数据对象的时候，就可以先对数据对象进行处理，那么进行的是什么样的处理？</p>
<p>Virtual DOM</p>
<p>在 <a target="_blank" rel="noopener" href="https://juejin.im/post/5e06b4666fb9a0164f2956c0">Vue 源码系列一：Vue 中的 data 是如何驱动视图渲染的？</a> 中介绍了 Vue 的源码，分析了 Vue 的初始化顺序，主要就是为了生成虚拟 DOM 树。</p>
<p>浏览器不是已经有了 DOM 树了嘛？Vue 这个 DOM 树有什么不同的嘛？</p>
<p>其实没什么不同，因为这个树就是为了给浏览器进行渲染的，在这个树的 [官方文档](<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/render-function">https://cn.vuejs.org/v2/guide/render-function</a>. html#虚拟-DOM) 中，Vue 解释说使用这个虚拟 DOM 是</p>
<blockquote>
<p>Vue 通过建立一个<strong>虚拟 DOM</strong> 来追踪自己要如何改变真实 DOM。</p>
</blockquote>
<p>这就联系起来了。通过 <code>Object.defineProperty()</code> 方法可以劫持数据对象，通过虚拟 DOM 可以实现 MVVM 中的 ViewModel 功能，更加详细的东西就是在 set() 和 get() 里面了。</p>
<p>Vue 实现了一个订阅-发布模式。在这个模式中，Vue 实现了依赖收集和派发更新。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e0dd467e51d45410f1232f5">VUE 源码系列二：Vue 响应式原理解析（附超详细源码注释和原理解析）</a></p>
<p>在上面的文章中，作者通过源码解析详细介绍了这个订阅-发布模式，可以将其分成三个模块，</p>
<ul>
<li>Observer（劫持者）<ul>
<li>给对象的属性添加 getter 和 setter，用于依赖收集和派发更新</li>
<li>被用在 defineReactive 中，使得对象的每个属性都添加上 getter 和 setter 成为响应式。</li>
</ul>
</li>
<li>Dep（依赖收集）<ul>
<li>收集订阅者 <code>subs : Array&lt;Watcher&gt;</code> ，用在 defineReactive 的重写 get 中为 <code>dep.depend </code> 方法，为数据提供收集功能。</li>
<li>同时提供了发布更新的作用，在 defineReactive 的重写 set 中为 <code>dep.notify()</code> 方法。</li>
</ul>
</li>
<li>Watcher（观察者）<ul>
<li>在 Dep 发布更新后使用 <code>dep.notify()</code> 方法，循环执行 Dep 中的 <code>subs[i].update()</code> 使得数据相关的订阅者更新视图。</li>
<li>在 <code>watcher.update()</code> 中，使用了 <code>queuewatcher()</code> 方法，通过一个队列检查是否含有目标观察者，使得视图不会重复刷新。在队列中异步执行 <code>flushSchedulerQueue()</code> 方法，在此方法中排序 queue 确保父子组件的顺序更新，然后执行 <code>run()</code> 函数，使用新旧 value 值执行 Watcher 的回调 <code>cb.call()</code> 。</li>
</ul>
</li>
</ul>
<p><img src="https://image-static.segmentfault.com/162/469/1624694337-5a8fcee951762_articlex" alt="响应系统源码版"></p>
<p><img src="https://image-static.segmentfault.com/275/841/2758414791-5c99c0ef4e3c8_articlex" alt="clipboard. png"></p>
<p>这两张图片可以用来参考，来自 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013338801">从发布-订阅模式到 Vue 响应系统</a></p>
<p><strong>总结一下</strong></p>
<p>Vue 通过 <code>Object.defineProperty()</code> 实现对数据对象的劫持，通过 Observer 类定义 getter 和 setter，使得对象的所有属性都具备响应性，在 <code>getter()</code> 中通过依赖收集 Dep 的 <code>dep.depends()</code> 管理订阅者（当数据被 get 即视为被订阅），在 <code>setter()</code> 中通过 <code>dep.notify()</code> 函数向订阅了该数据对象的 Watcher 发送 <code>update()</code> ，Watcher 接收到更新信息后确定组件更新顺序然后映射到 Virtual DOM 中去，Virtual DOM 通过 <code>patch</code> 新旧节点，通过 <code>diff</code> 算法实现对新旧节点的对比，对同层的树节点进行比较而非对树进行逐层搜索遍历。然后生成真实 DOM。</p>
<p>这是 Vue2. x 的响应式原理，在 Vue3. 0 中，官方重写了响应式的实现，改用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy"> <code>Proxy</code> </a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect"> <code>Reflect</code> </a> 代替 <code>Object.defineProperty()</code> 。可以实现对更多数据的操作比如数组元素的劫持和更多的劫持方式。</p>
<h2 id="Vue-的生命周期"><a href="#Vue-的生命周期" class="headerlink" title="Vue 的生命周期"></a>Vue 的生命周期</h2><p>![Vue 实例生命周期](<a target="_blank" rel="noopener" href="https://cn.vuejs.org/images/lifecycle">https://cn.vuejs.org/images/lifecycle</a>. png)</p>
<p>如果是 keep-alive 的话还有两个：activated 和 deactivated</p>
<p>keep-alive 的生命周期</p>
<p>1. activated： 页面第一次进入的时候，钩子触发的顺序是 created-&gt;mounted-&gt;activated<br>2. deactivated: 页面退出的时候会触发 deactivated，当再次前进或者后退的时候只触发 activated</p>
<p>那么 keep-alive 是什么？</p>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#keep-alive"> <code>keep-alive</code> </a> 是 Vue 提供的一个抽象组件， <code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似， 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p>
<p>这是 Vue 对象的生命周期，那么在 Vue 的父子组件中的生命周期是什么样的？</p>
<p><strong>渲染过程：</strong><br>父组件挂载完成一定是等子组件都挂载完成后，才算是父组件挂载完，所以父组件的 mounted 在子组件 mouted 之后<br>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
<p><strong>子组件更新过程：</strong></p>
<p>1. 影响到父组件： 父 beforeUpdate -&gt; 子 beforeUpdate-&gt;子 updated -&gt; 父 updted<br>2. 不影响父组件： 子 beforeUpdate -&gt; 子 updated</p>
<p><strong>父组件更新过程：</strong></p>
<p>1. 影响到子组件： 父 beforeUpdate -&gt; 子 beforeUpdate-&gt;子 updated -&gt; 父 updted<br>2. 不影响子组件： 父 beforeUpdate -&gt; 父 updated</p>
<p><strong>销毁过程：</strong><br>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
<p>所以不管是加载更新还是销毁都是父组件会等待子组件完后操作后才执行操作。</p>
<h2 id="v-model-是什么？"><a href="#v-model-是什么？" class="headerlink" title="v-model 是什么？"></a>v-model 是什么？</h2><p>v-model 是经常用来双向绑定数据的一个语法，实际是一个 v-bind 和 v-on 结合的一个语法糖，等同于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v - bind: value = <span class="string">&quot;msg&quot;</span></span><br><span class="line">v - on: input = <span class="string">&quot;msg=$event.target.value&quot;</span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#v-bind"> <code>v-bind</code> </a> 动态地绑定一个或多个特性，或一个组件 prop 到表达式。</p>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#v-on"> <code>v-on</code> </a> 绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</p>
<p>也就是说 v-model 通过绑定数据和绑定数据并监听数据的变化，形成双向绑定。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5e3647816fb9a030133074b0">VUE 源码系列七：v-model 实现原理</a></p>
<p>这篇文章则是从源码角度去解释 v-model，并不是简单的转换为 v-bind 和 v-on。只是在最终结果上是一样的。</p>
<h2 id="Vue-组件是什么？"><a href="#Vue-组件是什么？" class="headerlink" title="Vue 组件是什么？"></a>Vue 组件是什么？</h2><p>简单说 Vue 组件是一个可以复用的 Vue 实例，通过将网页组件化，可以更加快捷的搭建更多的网页，所以 Vue 组件最主要的目的是复用，类似 Bootstrap 的组件库、Element-UI，他们其实都是组件库，通过自己设计的组件，形成组件库。</p>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components">https://cn.vuejs.org/v2/guide/components</a>. html 是 Vue 关于组件的文档，以及后续的深入组件内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue. component(<span class="string">&#x27;my-component-name&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通常来说，我们可以使用这样的格式来注册一个组件，这种格式下注册的组件是可以全局使用的，但是很明显当你的页面比较多的时候，全局使用组件会造成一定程度的冗余，所以你可以通过变量赋值，然后通过 Vue 实例的 <code>components</code> 属性来添加当前实例的组件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">&quot;component-a&quot;</span>: ComponentA,</span><br><span class="line">    <span class="string">&quot;component-b&quot;</span>: ComponentB,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在设计组件的时候，我们需要考虑这个组件需要什么，以及他最后会呈现什么样子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;blog-post&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// 在 JavaScript 中是 camelCase 的</span></span><br><span class="line">  props: [<span class="string">&quot;postTitle&quot;</span>],</span><br><span class="line">  template: <span class="string">&quot;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过 <code>props</code> 可以为组件添加属性，这个属性是可以由父组件传递给子组件使用的。可以理解为这是一种函数模式，通过传入参数，使得组件呈现不同的样子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;base-checkbox&quot;</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">&quot;checked&quot;</span>,</span><br><span class="line">    event: <span class="string">&quot;change&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: <span class="built_in">Boolean</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type=&quot;checkbox&quot;</span></span><br><span class="line"><span class="string">      v-bind:checked=&quot;checked&quot;</span></span><br><span class="line"><span class="string">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>除了 <code>props</code> 以外，我们还可以给组件添加自定义的事件属性，</p>
<p>注意这里在 <code>template</code> 中使用的是 <code>v-bind</code> 和 <code>v-on</code> 而不是 <code>v-model</code> ，虽然他们所实现的目的是一样的，但是由于方便以及参数传输更加清楚，我们在使用这个组件的时候，通常使用 <code>v-model</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-checkbox</span> <span class="attr">v-model</span>=<span class="string">&quot;lovingVue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样对应过来， <code>lovingVue</code> 属性绑定在了组件的 <code>checked</code> 属性上，并且在发生 change 事件时也会通过 <code>v-on</code> 方法返回到 <code>lovingVue</code> 属性上，实现子组件参数与父组件属性间的双重绑定。</p>
<p>更多的细节可以参考官方的详细文档，你就会发现组件其实和实例拥有几乎一模一样的属性和方法，包括 <code>computed</code> <code>watch</code> 以及生命周期方法。</p>
<p>但是我们可以看到，在 <code>template</code> 的编写过程中，我们完全得不到语法提示，因为他是一个字符串属性。</p>
<p>所以更好的办法是我们把组件写成一个实例。通过局部引入来进行调用。也就是单文件组件。</p>
<p>在单文件组件中，组件编写更加的方便，同时数据上的传递思路也更加明确。</p>
<h3 id="关于插槽"><a href="#关于插槽" class="headerlink" title="关于插槽"></a>关于插槽</h3><p>插槽是 Vue 组件中一个很重要的方法，简单来说，插槽的目的是提供另外一种参数传递的方式，</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span> Your Profile <span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当你使用了一个 <code>navigation-link</code> 的组件时，正常情况下，组件间的数据都会被忽略，因为对于组件来说，中间的数据没有任何意义，如果不能正确的传递参数，中间的数据很容易打乱组件的结构。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是当组件中设定了一个 <code>slot</code> 标签后，父组件在使用子组件时，标签内部的信息都会被转移到 <code>slot</code> 标签中，而不是被直接抛弃。所以最后会渲染成:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span>&gt;</span> Your Profile <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>插槽中不仅可以填写这种纯文本，使用 HTML 代码甚至是使用 <code>{{}}` 格式包裹起来的数据属性也是可以的。

但是在使用 `{{}}</code> 格式传递数据时我们需要思考一个问题，我们是在使用子组件的时候，在子组件标签中间使用的 <code>{{}}</code> ，那么里面的属性我们自然是填入父组件的数据属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span> &#123;&#123; user.name &#125;&#125; <span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以用作用域来解释，即子组件的作用域，仅仅是在子组件中，甚至说在父组件中这个子组件的标签属性，也是数据父组件的作用域范围内，所以我们可以通过标签属性来传递父组件的数据到子组件中。只有数据传递过去后，才能算是子组件的数据属性，属于子组件的作用域范围。</p>
<p>更多详细的关于插槽的信息参考文档 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-slots">https://cn.vuejs.org/v2/guide/components-slots</a>. html</p>
<p>需要了解的包括有插槽的内容、作用域、默认内容、具名插槽、插槽 prop、动态插槽名等相关知识。</p>
<h3 id="关于动态组件"><a href="#关于动态组件" class="headerlink" title="关于动态组件"></a>关于动态组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">&quot;currentTabComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在经典 Vue 示例中，我们经常会看到 <code>&lt;router-view&gt;</code> 这个标签，这个标签常常使用在 Vue 项目的入口 <code>App.vue</code> 中，用来对视图进行切换，在实际项目中，当父组件动态调用子组件的时候，通常来说，在切换子组件后子组件会被销毁。但是当我们添加 <code>&lt;keep-alive&gt;</code> 标签后，被切换隐藏掉的子组件并不会被销毁，这样可以在特定场景下， 提升网页反应速度。</p>
<p>在测试的时候发现在 <code>&lt;router-view&gt;</code> 外也是可以使用 <code>&lt;keep-alive&gt;</code> 来实现同样的效果。</p>
<h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a><a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/">Vue Router</a></h2><blockquote>
<p>Vue Router 是 <a target="_blank" rel="noopener" href="http://cn.vuejs.org/">Vue. js</a> 官方的路由管理器。它和 Vue. js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p>
<ul>
<li>嵌套的路由/视图表</li>
<li>模块化的、基于组件的路由配置</li>
<li>路由参数、查询、通配符</li>
<li>基于 Vue. js 过渡系统的视图过渡效果</li>
<li>细粒度的导航控制</li>
<li>带有自动激活的 CSS class 的链接</li>
<li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li>
<li>自定义的滚动条行为</li>
</ul>
</blockquote>
<p>和大部分的路由管理器一样，Vue Router 通过对 URL 进行正则匹配指导用户转向不同的页面，和一些服务端的路由不同的是，Vue Router 通常用于建立单页面应用，这里的单页面并不是指只有一个页面，而是通过在同一个页面，通过路由的不同显示不同的预先写好的模板页面。</p>
<p>Vue Router 默认使用 <code>hash</code> 模式 URL</p>
<p><code>http://localhost:8080/#/login</code></p>
<p>通过 <code>#</code> 区分浏览器 URL 和 Vue Router 路由所使用的 URL。在 <code>hash</code> 模式下，可以更加方便的理解整个页面程序的路由，但是我们会发现他不太美观，如果你想使用正常的浏览器形式的 URL，需要修改 Vue Router 的模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode: <span class="string">&quot;history&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><code>http://localhost:8080/login</code></p>
<p>需要注意的时，这是在 Vue 提供的临时服务器中，所以可能感受不到 Vue 的单页面应用和其他的多页面应用的区别，因为 Vue 的临时服务器会通过 Vue 的 Router 解析端口传递的 URL 请求并指向到正确的显示页面。</p>
<p>回到浏览器上，当我们输入了一个 URL 后，如果是普通的多页面应用，会通过 URL 解析并指向目标 HTML 文件，返回文件进行渲染，对单页面应用来说，一个是前端页面的不同路由，一个是服务器接口的路由。如果不使用 <code>hash</code> 模式通过 <code>#</code> 进行区分的话，是不能通过 <code>http://localhost:8080/login</code> 直接访问到 <code>login</code> 页面的</p>
<img src="/images/image-20200401163121542." class="img" title="png 404">

<p>当前使用 Vue 生成的静态文件作为 Python Django 服务器的模板，通过 <code>/</code> 路由确定 <code>index.html</code> 的位置并显示 Vue 页面，然后开始使用 Vue 的路由。如果直接在 URL 栏上输入 Vue 的路由是不能转到目标页面的。</p>
<p>关于路由方面需要了解的大概就是嵌套路由，正则表达，路由参数，有的部分是和组件有些类似的地方，比如路由参数和组件间的参数传递，通常来说路由参数是用于同级组件间的参数传递，组件间参数是父子组件间的数据传递。</p>
<h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><blockquote>
<p>“导航”表示路由正在发生改变。</p>
</blockquote>
<p><strong>完整的导航解析流程</strong></p>
<ol>
<li>导航被触发。</li>
<li>在失活的组件里调用离开守卫。</li>
<li>调用全局的 <code>beforeEach</code> 守卫。</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2. 2+)。</li>
<li>在路由配置里调用 <code>beforeEnter</code> 。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code> 。</li>
<li>调用全局的 <code>beforeResolve</code> 守卫 (2. 5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 <code>afterEach</code> 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li>
</ol>
<p>所以守卫实际上是设定好的函数，通过路由变化触发。在完整的 beforeEach=&gt;beforeRouteUpdate=&gt;beforeEnter=&gt;beforeRouteEnter=&gt;afterEach 状态路径上对网页进行控制。</p>
<p>相当于是路由的生命周期，类似于组件的生命周期一样。</p>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a><a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh/">Vuex</a></h2><blockquote>
<p>Vuex 是一个专为 Vue. js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-devtools">devtools extension</a>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p>
</blockquote>
<h3 id="状态管理模式是什么？"><a href="#状态管理模式是什么？" class="headerlink" title="状态管理模式是什么？"></a>状态管理模式是什么？</h3><p>简单说就是一个全局的数据状态，多个组件可以共享这个状态。避免多个组件间的复杂的数据传递和状态修改的实现。</p>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：</p>
<ol>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地**提交 (commit) mutation**。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count++;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在，你可以通过 <code>store.state</code> 来获取状态对象，以及通过 <code>store.commit</code> 方法触发状态变更：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.commit(<span class="string">&quot;increment&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(store.state.count); <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>再次强调，我们通过提交 mutation 的方式，而非直接改变 <code>store.state.count</code> ，是因为我们想要更明确地追踪到状态的变化。这个简单的约定能够让你的意图更加明显，这样你在阅读代码的时候能更容易地解读应用内部的状态改变。此外，这样也让我们有机会去实现一些能记录每次状态改变，保存状态快照的调试工具。有了它，我们甚至可以实现如时间穿梭般的调试体验。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF/" rel="tag"># 学习前端</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/11/01/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E5%8A%A0%E5%AF%86%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F-%E5%8F%82%E7%85%A7signal/" rel="prev" title="端对端加密通讯系统">
      <i class="fa fa-chevron-left"></i> 端对端加密通讯系统
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/22/%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/" rel="next" title="前端资源以及相关文章整理">
      前端资源以及相关文章整理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90"><span class="nav-number">1.</span> <span class="nav-text">前端资源</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0"><span class="nav-number">1.1.</span> <span class="nav-text">相关文章</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6"><span class="nav-number">2.</span> <span class="nav-text">知识框架</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTML-%E6%95%B4%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">HTML 整理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTML-DOM"><span class="nav-number">3.1.</span> <span class="nav-text">HTML DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS-DOM"><span class="nav-number">3.1.1.</span> <span class="nav-text">CSS DOM</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CSS-%E6%95%B4%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">CSS 整理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%90%84%E4%B8%AA%E5%B8%83%E5%B1%80"><span class="nav-number">4.1.</span> <span class="nav-text">关于各个布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.2.</span> <span class="nav-text">关于盒模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%9D%83%E9%87%8D"><span class="nav-number">4.3.</span> <span class="nav-text">CSS 语句的权重</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%82%E7%9B%B4%E5%AF%B9%E9%BD%90"><span class="nav-number">4.4.</span> <span class="nav-text">垂直对齐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-BFC"><span class="nav-number">4.5.</span> <span class="nav-text">关于 BFC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS3-%E6%9B%B4%E6%96%B0%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">4.6.</span> <span class="nav-text">CSS3 更新了什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E8%BE%B9%E6%A1%86%E5%B1%9E%E6%80%A7"><span class="nav-number">4.6.1.</span> <span class="nav-text">新的边框属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E8%83%8C%E6%99%AF%E5%B1%9E%E6%80%A7"><span class="nav-number">4.6.2.</span> <span class="nav-text">新的背景属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C%EF%BC%88%E5%A5%BD%E7%9C%8B"><span class="nav-number">4.6.3.</span> <span class="nav-text">渐变效果（好看</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="nav-number">4.6.4.</span> <span class="nav-text">新的文本属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript-%E6%95%B4%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">JavaScript 整理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">5.1.</span> <span class="nav-text">关于原型链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="nav-number">5.2.</span> <span class="nav-text">关于变量提升</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-Promise-%E5%92%8C-Async-Await"><span class="nav-number">5.3.</span> <span class="nav-text">关于 Promise 和 Async&#x2F;Await</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.4.</span> <span class="nav-text">关于包装对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-Null-%E5%92%8C-Undefined"><span class="nav-number">5.5.</span> <span class="nav-text">关于 Null 和 Undefined</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-JavaScript-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6"><span class="nav-number">5.6.</span> <span class="nav-text">关于 JavaScript 执行机制和事件循环机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">5.7.</span> <span class="nav-text">闭包是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E9%97%AD%E5%8C%85%E6%A8%A1%E6%8B%9F%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="nav-number">5.7.1.</span> <span class="nav-text">用闭包模拟私有方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.8.</span> <span class="nav-text">JavaScript 的面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">5.8.1.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6-%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">5.8.1.1.</span> <span class="nav-text">ES6 的继承</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">5.8.2.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">5.8.3.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-ES6-%E6%9B%B4%E6%96%B0%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">5.9.</span> <span class="nav-text">JavaScript ES6 更新了什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#let-%E5%91%BD%E4%BB%A4"><span class="nav-number">5.9.1.</span> <span class="nav-text">let 命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">5.9.1.1.</span> <span class="nav-text">新的作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="nav-number">5.9.1.2.</span> <span class="nav-text">函数表达式和函数声明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-%E5%91%BD%E4%BB%A4"><span class="nav-number">5.9.2.</span> <span class="nav-text">const 命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B6%E5%B1%82%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.9.2.1.</span> <span class="nav-text">顶层对象和全局对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="nav-number">5.9.3.</span> <span class="nav-text">变量解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3"><span class="nav-number">5.9.4.</span> <span class="nav-text">字符串相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="nav-number">5.9.5.</span> <span class="nav-text">正则表达式的改进</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#u-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">5.9.5.1.</span> <span class="nav-text">u 修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#y-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">5.9.5.2.</span> <span class="nav-text">y 修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#s-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">5.9.5.3.</span> <span class="nav-text">s 修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80"><span class="nav-number">5.9.5.4.</span> <span class="nav-text">后行断言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B7%E5%90%8D%E7%BB%84%E5%8C%B9%E9%85%8D"><span class="nav-number">5.9.5.5.</span> <span class="nav-text">具名组匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E7%B4%A2%E5%BC%95"><span class="nav-number">5.9.5.6.</span> <span class="nav-text">正则匹配索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-prototype-matchAll"><span class="nav-number">5.9.5.7.</span> <span class="nav-text">String. prototype. matchAll()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">5.9.6.</span> <span class="nav-text">数值的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BigInt"><span class="nav-number">5.9.6.1.</span> <span class="nav-text">BigInt</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">5.9.7.</span> <span class="nav-text">函数的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E8%AE%BE%E7%BD%AE"><span class="nav-number">5.9.7.1.</span> <span class="nav-text">参数默认值设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rest-%E5%8F%82%E6%95%B0"><span class="nav-number">5.9.7.2.</span> <span class="nav-text">rest 参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="nav-number">5.9.7.3.</span> <span class="nav-text">箭头函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%BE%E8%B0%83%E7%94%A8%E5%92%8C%E5%B0%BE%E9%80%92%E5%BD%92"><span class="nav-number">5.9.7.4.</span> <span class="nav-text">尾调用和尾递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="nav-number">5.9.7.5.</span> <span class="nav-text">柯里化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.9.7.6.</span> <span class="nav-text">尾递归优化的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">5.9.8.</span> <span class="nav-text">数组的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.9.8.1.</span> <span class="nav-text">扩展运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-from"><span class="nav-number">5.9.8.2.</span> <span class="nav-text">Array. from()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-of"><span class="nav-number">5.9.8.3.</span> <span class="nav-text">Array. of()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copyWithin"><span class="nav-number">5.9.8.4.</span> <span class="nav-text">copyWithin()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#find-%E5%92%8C-findInedx"><span class="nav-number">5.9.8.5.</span> <span class="nav-text">find() 和 findInedx()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fill"><span class="nav-number">5.9.8.6.</span> <span class="nav-text">fill()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#entries-%EF%BC%8C-keys-%E5%92%8C-values"><span class="nav-number">5.9.8.7.</span> <span class="nav-text">entries() ， keys() 和 values()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#includes"><span class="nav-number">5.9.8.8.</span> <span class="nav-text">includes()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flat-flatMap"><span class="nav-number">5.9.8.9.</span> <span class="nav-text">flat(), flatMap()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%A9%BA%E4%BD%8D%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">5.9.8.10.</span> <span class="nav-text">数组空位的处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-prototype-sort-%E6%8E%92%E5%BA%8F%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="nav-number">5.9.8.11.</span> <span class="nav-text">Array. prototype. sort() 排序稳定性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">5.9.9.</span> <span class="nav-text">对象的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AE%80%E5%86%99%E6%96%B9%E6%B3%95"><span class="nav-number">5.9.9.1.</span> <span class="nav-text">属性的简写方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89"><span class="nav-number">5.9.9.2.</span> <span class="nav-text">对象属性定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84-name-%E5%B1%9E%E6%80%A7"><span class="nav-number">5.9.9.3.</span> <span class="nav-text">方法的 name 属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%AF%E6%9E%9A%E4%B8%BE%E6%80%A7%E5%92%8C%E9%81%8D%E5%8E%86"><span class="nav-number">5.9.9.4.</span> <span class="nav-text">属性的可枚举性和遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#super-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">5.9.9.5.</span> <span class="nav-text">super 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%A6-%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.9.9.6.</span> <span class="nav-text">… 扩展运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.9.9.7.</span> <span class="nav-text">链判断运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Null-%E5%88%A4%E6%96%AD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.9.9.8.</span> <span class="nav-text">Null 判断运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B0%E6%96%B9%E6%B3%95"><span class="nav-number">5.9.10.</span> <span class="nav-text">对象的新方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Symbol"><span class="nav-number">5.9.11.</span> <span class="nav-text">Symbol</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Symbol-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.9.11.1.</span> <span class="nav-text">Symbol 的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-Symbol-%E6%9D%A5%E5%AE%9E%E7%8E%B0-Singleton-%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.9.11.2.</span> <span class="nav-text">通过 Symbol 来实现 Singleton 模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Symbol-%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">5.9.11.3.</span> <span class="nav-text">Symbol 的属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-%E5%92%8C-Map"><span class="nav-number">5.9.12.</span> <span class="nav-text">Set 和 Map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Set-%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">5.9.12.1.</span> <span class="nav-text">Set 实例的属性和方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C"><span class="nav-number">5.9.12.2.</span> <span class="nav-text">遍历操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WeakSet"><span class="nav-number">5.9.12.3.</span> <span class="nav-text">WeakSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map"><span class="nav-number">5.9.12.4.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map-%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">5.9.12.5.</span> <span class="nav-text">Map 的属性和方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2"><span class="nav-number">5.9.12.6.</span> <span class="nav-text">与其他数据结构的互相转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy"><span class="nav-number">5.9.13.</span> <span class="nav-text">Proxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect"><span class="nav-number">5.9.14.</span> <span class="nav-text">Reflect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Promise"><span class="nav-number">5.9.15.</span> <span class="nav-text">Promise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterator"><span class="nav-number">5.9.16.</span> <span class="nav-text">Iterator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Generator"><span class="nav-number">5.9.17.</span> <span class="nav-text">Generator</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#yield-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">5.9.17.1.</span> <span class="nav-text">yield 表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-Generator-%E5%AE%8C%E6%88%90%E5%BC%82%E6%AD%A5"><span class="nav-number">5.9.18.</span> <span class="nav-text">通过 Generator 完成异步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5"><span class="nav-number">5.9.18.1.</span> <span class="nav-text">异步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B"><span class="nav-number">5.9.18.2.</span> <span class="nav-text">协程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84-Generator-%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.9.18.3.</span> <span class="nav-text">协程的 Generator 实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thunk-%E5%87%BD%E6%95%B0"><span class="nav-number">5.9.18.4.</span> <span class="nav-text">Thunk 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JavaScript-%E8%AF%AD%E8%A8%80%E7%9A%84-Thunk-%E5%87%BD%E6%95%B0"><span class="nav-number">5.9.18.5.</span> <span class="nav-text">JavaScript 语言的 Thunk 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thunkify-%E6%A8%A1%E5%9D%97"><span class="nav-number">5.9.18.6.</span> <span class="nav-text">Thunkify 模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#co-%E6%A8%A1%E5%9D%97"><span class="nav-number">5.9.18.7.</span> <span class="nav-text">co 模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Async-%E5%87%BD%E6%95%B0"><span class="nav-number">5.9.19.</span> <span class="nav-text">Async 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%AE%8C%E6%88%90%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">5.9.19.1.</span> <span class="nav-text">按顺序完成异步操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">5.9.20.</span> <span class="nav-text">Class 的基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class-%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">5.9.21.</span> <span class="nav-text">Class 的继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Module%EF%BC%88%E6%A8%A1%E5%9D%97%EF%BC%89%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="nav-number">5.9.22.</span> <span class="nav-text">Module（模块）的语法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="nav-number">5.10.</span> <span class="nav-text">防抖和节流</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TypeScript-%E6%95%B4%E7%90%86"><span class="nav-number">6.</span> <span class="nav-text">TypeScript 整理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.</span> <span class="nav-text">设计模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E4%BA%9B%E4%BB%80%E4%B9%88"><span class="nav-number">8.</span> <span class="nav-text">关于浏览器需要知道些什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Node-js-%E6%95%B4%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">Node. js 整理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Vue-%E6%95%B4%E7%90%86"><span class="nav-number">10.</span> <span class="nav-text">Vue 整理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">10.1.</span> <span class="nav-text">Vue 是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MVVM-%E6%A1%86%E6%9E%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">10.1.1.</span> <span class="nav-text">MVVM 框架是什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%EF%BC%9F"><span class="nav-number">10.2.</span> <span class="nav-text">Vue 是如何实现响应式的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">10.3.</span> <span class="nav-text">Vue 的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#v-model-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">10.4.</span> <span class="nav-text">v-model 是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">10.5.</span> <span class="nav-text">Vue 组件是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E6%8F%92%E6%A7%BD"><span class="nav-number">10.5.1.</span> <span class="nav-text">关于插槽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6"><span class="nav-number">10.5.2.</span> <span class="nav-text">关于动态组件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue-Router"><span class="nav-number">10.6.</span> <span class="nav-text">Vue Router</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB"><span class="nav-number">10.6.1.</span> <span class="nav-text">导航守卫</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vuex"><span class="nav-number">10.7.</span> <span class="nav-text">Vuex</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">10.7.1.</span> <span class="nav-text">状态管理模式是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#store"><span class="nav-number">10.7.2.</span> <span class="nav-text">store</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Pisho"
      src="/images/icon.jpg">
  <p class="site-author-name" itemprop="name">Pisho</p>
  <div class="site-description" itemprop="description">本站看运气访问进来,主要是本人的一些学习笔记,一般没有什么干货。不过还是希望能够帮助你学习到什么。由于域名到期，所以换成了 MOE 二次元域名。😄</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/PishoLu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PishoLu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:luhongyu.hi@qq.com" title="E-Mail → mailto:luhongyu.hi@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://pisho.me/images/wechatfriend.png" title="Wechat → https:&#x2F;&#x2F;pisho.me&#x2F;images&#x2F;wechatfriend.png" rel="noopener" target="_blank"><i class="fab fa-weixin fa-fw"></i>Wechat</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/profiles/76561198212983353/" title="Steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;profiles&#x2F;76561198212983353&#x2F;" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i>Steam</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pisho</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
